                    query processng
                    ---------------
        Linas Vepstas <linasvepstas@gmail.com>
                  Created 18 March 2008
                  Revised on 13 May 2008

This directory contains code that implements a subgraph isomorphism
algorithm, and then uses this algorithm to perform query processing.
The first part of the file describes the generic algorithm; the second
part describes its application to query processing.

XXX As of 13 may, minor changes to the relex output might have broken
the query processing part of the code. This code might trip over the
new way in which sentences are specified.... or maybe this code will
work?  Untested...


Subgraph Isomorphism Discovery
------------------------------
Given a small (hyper-)graph and a bigger "universe" (hyper-)graph, the
subgraph isomorphism algorithm finds and returns the corresponding
smaller graph within the universe graph.  The smaller graph may include
one or more variable nodes or links, which will match any corresponding
node or link in the universe; for this reason, subgraph matching
can be used to perform query processing, to "fill in the blanks".

The subgraph matching algorithm is fairly general, but with an
important restriction on how the subgraph is specified. Every
hypergraph has a corresponding incidence graph (or "Levi graph"),
where the nodes and links of the hypergraph are mapped to vertices
on the incidence graph, while the edges of the incidence graph
reflect the connectivity of the hypergraph.  The input to the
algorithm must be specified as a set of trees in the incidence
graph, with some nodes shared between the trees, so as to form
a single, connected graph. This is a natural fit for the currently
envisioned linguistics applications; for example:

  _subj(John, throw)
  _obj(ball, throw)

consists of two trees, with a shared leaf (throw) connecting the
two trees together to form a single graph.  The tree input keeps
the algorithm simple, as the subgraph matching is performed recursively,
one tree at a time.

The algorithm is kept generic, by means of two callbacks.  One callback
simply reports a solution, and provides a map between nodes/links in
the subgraph, and nodes/links in the universe.  The second callback is
used to determine when two nodes/links are identical.  For example,
in linguistic matching, two nodes might be considered to be identical
when they are both instances of the same concept; the details of what
constitutes "the same concept" are left to the callback.

As a concrete example, consider the statement and query: "John threw a
ball. What did John throw?" The query takes the form:

   link[40 <_obj,link[26 <throw_49,_$qVar_05>]>]
   link[40 <_subj,link[26 <throw_49,John_51>]>]

which is sovled by:
   link[40 <_obj,link[26 <throw_22,ball_79>]>]
   link[40 <_subj,link[26 <throw_22,John_85>]>]

with the explicit mapping given by:
    atom _obj maps to _obj
    atom _subj maps to _subj
    atom throw_49 maps to throw_22
    atom John_51 maps to John_85
    atom _$qVar_05 maps to ball_79


Algorithm overview
------------------
The following sections present the algorithm details.

Terminology
-----------
The incidence graph of a hypergraph is called the "Levi graph".
Levi graphs are bipartite; although the algorithm does not make
use of this.

The Basic Algorithmic Idea
--------------------------
The basic idea is to treat the query as a graph, in which are embedded
some number of variables or unknowns. This query graph can be loosely
understood to be kind of like a predicate, in that the query is solved
only when the variables take on appropriate values.

The goal of query processing is to scan the collection of all knowledge,
(the "universe hypergraph"), looking for a subgraph that matches the
predicate. The nodes that fit where the unknowns would go are then the
answer to the query.

The problem of finding certain subgraphs within graphs is known as the
"subgraph isomorphism problem" or the "subgraph matching problem", and
one uses a "subgraph isomorphism algorithm" to find the match.


Currently Implemented Algorithm
-------------------------------
0) In the following, the word "atom" may refer to either a hypergraph
   node, or a hypergraph link. Corresponding to every hypergraph is
   an incidence graph. The atoms of a hypergraph are vertices of
   the incidence graph. The convetion used here is that the incidence
   graph is a directed graph; thus, only hypergraph links have
   outgoing incidence graph edges; whereas hypergraph nodes have
   no outgoing incidence graph edges.

   The implemented algorithm makes direct use of the incidence
   graph, and only indirectly to the hypergraph. The insistence
   on making the incidence graph be a directed graph helps make
   traversal more direct and removes ambiguity.

   [OpenCog-specific remarks are in square brackets.  In OpenCog, the
   outgoing incidence graph edges are given by the "outgoing set" of
   the atom.]

1) Input consists a sequence of the roots of incidence trees, that is,
   of a list of subgraphs of the incidence graph that are trees.  Thus,
   by definition, the incidence tree root must be a hypergraph link,
   as hypergraph node cannot, by definition, have a non-trivial
   incidence tree under it.  Each tree is, by definition, acyclic.

   Thus, for example: _subj(row, Steve) has _subj at the root of the
   tree, with "row" and "Steve" as leaves.

   In the following [and in the code], each tree will be refered to as
   a "predicate"; although this term is potentially misleading, as the
   resemblance to logical predicates is superficial.

   Distinct trees may have common verticies.  The common verticies
   act to join together the trees into a single, connected graph.
   Disconnected graphs are not allowed; the algorithm will fail to
   find and solve disconnected components.  The graph as a whole may
   contain loops (the decomposition into trees keeps the algorithm
   from having to explicitly accomadate loops).

   A list of the common, or shared, vertices is made; this list is
   used later in the algorithm, to find all trees connnected to a
   specific vertex. [This list is implemented as PatternMatch::root_map]

   The universe graph may have any structure whatsoever; there is no
   requirement that the universe be decomposable into trees.

2) Input includes a list of the bound variables in the expressions.
   Thus, for example _obj(row,_$qVar) has _$qVar is the variable
   to be solved for. The list serves to explicitly identify the
   variables, so that they do not need to be computed or guessed.
   The designated variables need not be leaf verticies. There may be
   zero, one or more variables.

3) Node equivalence is determined by means of a callback; the user
   may implement any notion at all of "equivalance".  In particular,
   the equivalence callback may be used as an alternate way to perform
   variable bindings, with the callback itself determining when a
   node is variable, and what the allowed bindings to it may be.

   [This callback is implemented in PatternMatchCallback::node_match().
   In opencog, links are not given unique names, only types. Thus,
   links are considered to match when thier types match, and the
   tree given by the link's outoging set also matches. In particular,
   the node_match() callback is never called for links.]

4) Pick the first tree. Get the type of the root atom of the
   first tree. Get a list of all atoms in the universe of this type.
   These are the "candidate atoms".  Iterate over this list.
   The iterator is the next step below (step 5).

   [This step is implemented in PatternMatch::match(), which calls
   PatternMatch::do_candidate() for each candidate root.]

5) Initiate a recursive tree matching algorithm, comparing the
   incidence tree of the first predicate to that rooted at the
   candidate atom.

   First, the tree matching algo checks to see if the given
   node in the predicate is a variable; if so, then the match
   is considered to be successful, and the corresponding node
   in the universe is recorded as a solution.

   If the predicate itself is found in the universe, it is rejected.

   If the atom is a link, so that it has a non-zero number of outgoing
   edges, then the number of edges (the arity) of both the predicate
   and the corresponding lik in the universe, must be equal.

   The tree matching algorithm invokes the node-equivalence callback,
   as each pair of nodes is encountered.  Recursion is terminated when
   a mismatch is found.

   [This step is implemented in PatternMatch::tree_compare().
   Atoms with different types are rejected before the callback is
   called. Because links are anonymous, the callback is never
   called for links.]

6) Assuming a single tree has been sucessfully matched in the previous
   step, the next step is to find a predicate tree that has not yet been
   solved.  This is done by examining the list of all nodes that are
   shared between the most recently solved tree, looking for an unsolved
   tree.

   [This is implemented in PattherMatch::get_next_unsolved_pred()]

7) If an unsolved tree is found, then tree-matching, as described in
   step 5), resumes. However, the tree matching resumes at the shared
   node of the unsolved tree. The unsovled tree is recursively walked
   upwards, towards its root, with a tree match attempted at ever stage.

   The upwards recursion uses a stack to track state; this is required
   in the case of there being multiple possible matches to a tree:
   after finding one match, the stack may be popped to explore other
   possible matches.

   If the upwards recursion reaches the root of the predicate, the
   predicate is now considered to be solved. Go to step 6), to find
   other unsolved predicates.

   [This is implemented by two routines: PatternMatch::soln_up()
   and PatternMatch::pred_up(). These two routines alternate
   calls to each other, by traversing the *incoming* set of the
   current node in the predicate, and the candidate solution node.
   The incoming set takes one "upwards" in the tree.]

   [The stack of current state is maintained in PatternMatch::
   pred_handle_stack, etc. These are pushed as an upwards(incoming)
   edge is explored, and popped when the edge is rejected.]

   [Partial solutions are recorded in PatternMatch::var_solution and
   PatternMatch::predicate_solution.  These partial solutions must also
   be kept on stack, as a failed match at a later stage means that
   backtracking must be done. Since the partial solutions are used to
   find unsolved predicates, care must be taken that the partial
   solution is correct after backtracking: i.e. they must be popped
   as failed matches are encountered.]

   Note that mutiple solution graphs may overlap.  Thus, if the
   universe contains the statement: "John threw a ball and a rock."
   and the query is "What did John throw?", then there are two
   valid subgraph matches: "John threw a ball" and "John threw
   a rock".  Both of these solutions contain a common subgraph,
   "John threw...", which must be reachable, and reconsidered,
   after one solution is proposed. In particular, this implies
   that the partial solution state must also be kept on stack,
   so that the backtracking can be performed to find other,
   overlapping solutions.

8) If no unsolved tree is found, then the matching is complete.
   The full solution is reported via callback.  The callback may
   indicate that the search be terminated, or that it continue to
   find other possible solutions.

Summary
-------
The above describes the specific implemention of a subraph matching
algorithm. It is generic, in that it makes no reference to the
specifics of the actual data layout, or of node equivalences in the
data.  The only restriction made is that the input, query graph,
has been decomposed into a set of trees.

[On opencog, the entire implementation is in PatternMatch.[h, .cc].]

Foreach iterators
-----------------
The algorithm makes heavy use of "foreach" iterators to walk the
incoming and outgoing edges of an atom.  The "foreach" mechanism
has multiple advantages over other techniques, and it is important
to understand these.

A) The details of the Atom.h incoming and outgoing sets are abstracted.
   Thus, while the outgoing set uses std:vector, the incoming set uses
   a simple linked list. This detail is immaterial to the "foreach" user,
   as both look the same. The only requirement is that each edge is visited
   exactly once.

B) The foreach abstraction makes multi-threaded implementation,
   including mutex locking, much easier. In particular, the semantics
   of atomic locking of a forech traversal is much simpler than complexity
   of trying to lock a naked linked list for read-only or read-write
   traversal.

C) The foreach abstraction can (and will) have performance that is
   equal to a for-loop iteration over an array or linked list. This
   is because, when the set to be iterated over is a simple list or
   array, the foreach iterator can be implemented as an inline function.
   Modern compilers are able to inline such functions correctly,
   and optimize the result, providing performance equivalent to
   a raw for-loop iteration.

D) The foreach abstraction allows complex iterators to be implemented.
   Thus, the foeach abstraction eliminates the data copying associated
   with naive "filters", and thus can offer superior space *and* time
   performance over filters. For example, consider a long linked list
   consisting of many types of atoms, and one wants to perform a certain
   operation only on a specific type of atom. Traditional "filters"
   would make a copy of the list, incuding only the desired atom
   types in the copied list. This requires significant overhead:
   nodes must be copied, iterated over, and then freed.  The foreach
   abstraction allows a zero-copy filter to be implemented: the
   callback is invoked only for those nodes that match the filter
   criteria.

Ranking; Approximate matching
-----------------------------
Because the solution subgraph is returned, a ranking of the qality of
the solution can be performed in a post-processing stage, by applying
weights to links, etc.  There seems to be little advantage to computing
a ranking score during the graph search itself.

Since solutions are returned as they are found, each can be ranked on
the fly, and the search terminated once a solution that is "good enough"
has been found.

Note that one can used the existing framework to implement approximate
matching, but manually computing a partial-match score on the fly. One
would do this by accepting poor matches unconditionally, while also
keeping a running total score. If the running total gets too low, then
the current node match can be rejected.  At this point, the algo will
back-track, trying alternate matches. An approximate match is found
when matching has completed, without the running score having dipped too
low. Even after a match, there will be back-tracking, so other, nearby
solutions will also be found as well.

Two gotchas: probably need to export push-pop callbacks, in order to
enable the above approximate-matching scoring.  Also, note that during
matching, some nodes may be visited multiple times, even during the same
match attempt. This was a matter of convenience, but will screw up
partial scores, if not accounted for. 


Query Processing Overview
-------------------------
Query processing proceeds by taking English langauge sentences, 
passing them through the link-grammar perser, then through relex,
through the semanitic framing, and then importing the result into
opencog.

When a sentence is determined to be a query, the above-described
patern matching is performed on the contents of opencog, in an
attempt to find a matching result.  Pattern matching can be done
at several levels: at the relex level, or at the more abstract
semantic framing level.  Query processing at the relex level should
be used only when a very narrow, literal answer is desired. This
is because pattern matching at the relex level introduces very
little wiggle room.  Thus, for example, to answer the question
"What did John throw?" at the relex level,

    _subj(throw, John )
    _obj(throw, _$qVar)

The opencog server must contain a sentence that had parsed into
exactly the above form; so, for example: "John threw a ball"

    _subj(throw, John )
    _obj(throw, ball)

would provide a matching solution, whereas ...

(provide example)

Thus, a looser matching, based on deeper semantic understanding,
is desirable.  This is afforded by using the semantic framing 
matcher.


Relex pattern matching
----------------------
A detailed example of relex relationship matching follows.

"John threw a ball."

_subj(throw, John)
_obj(throw, ball)
tense(throw, past)
noun_number(ball, singular)
DEFINITE-FLAG(John, T)
noun_number(John, singular)

"What did John throw?"

_subj(throw, John)
_obj(throw, _$qVar)
tense(throw, past_infinitive)
HYP(throw, T)
QUERY-TYPE(_$qVar, what)
DEFINITE-FLAG(John, T)
noun_number(John, singular)

Eliminate the HYP and QUERY-TYPE from the question, since
the answer will never contain these. One is left with:

_subj(throw, John)
_obj(throw, _$qVar)
tense(throw, past_infinitive)
DEFINITE-FLAG(John, T)
noun_number(John, singular)

Clearly, the relex pattern of the question can be matched to 
the relex pattern of the answer, to find that _$qVar == ball.
(Some twiddling required to match tense correctly).
This type of relex relation-level setup, query massaging 
and node matching is implemented in RelexQuery.cc, RelexQuery.h
It seems to work, but hasn't undergone strenuous testing.

Pattern matching at the relex level is not always 
possible, as shown next.

Copula troubles:
----------------
Intensional/extensional inheritance causes problems for 
simple relex matching.

Yarn is a length of fibers.
_subj(be, yarn)
_obj(be, length)
tense(be, present)
of(length, fiber)
noun_number(length, singular)
noun_number(fiber, plural)
noun_number(yarn, uncountable)


Yarn is what?
(fails to parse in link-grammar)

What is yarn?

_subj(be, _$qVar)
_obj(be, yarn)
tense(be, present)
noun_number(yarn, uncountable)
COPULA-QUESTION-FLAG(yarn, T)
QUERY-TYPE(_$qVar, what)
noun_number(_$qVar, uncountable)

Note that the _subj and _obj are exchanged in the query, 
preventing a direct match.

Frame matching
--------------
The goal of working with frames rather than relex relations is
to escape from the stricturures of the syntactic relations, and
move to a more semantic interpretation.

Yarn is a length of fibers.

^1_Categorization:Category(be,length)
^1_Existance:Entity(be,yarn)
^2_Inheritence:Quality(of,length)
^2_Inheritence:Inheritor(of,fiber)
^2_Inheritence:Group(of,fiber)
^2_Inheritence:Instance(of,length)
^1_Partitive:Subset(of,length)
^1_Partitive:Group(of,fiber)
^1_Part_whole:Part(of,length)
^1_Part_whole:Whole(of,fiber)
^1_Physical_entity:Constituents(of,fiber)
^1_Physical_entity:Entity(of,length)
^1_Categorization:Item(be,yarn)
^1_Temporal_colocation:Time(present,be)
^1_Temporal_colocation:Event(present,be)


What is yarn?

^1_Existance:Entity(be,_$qVar)
^1_Categorization:Category(be,yarn)
^1_Temporal_colocation:Time(present,be)
^1_Temporal_colocation:Event(present,be)
^1_Categorization:Item(be,_$qVar)
^1_Entity:Entity(what,_$qVar)
^1_Questioning:Message(what,_$qVar)
^1_Attributes:Entity(what,_$qVar)

Trim the question to remove references to questioning (as the answer
won't possess these). Remove the "what" part as well. The question
becomes:

^1_Categorization:Category(be,yarn)
^1_Temporal_colocation:Time(present,be)
^1_Temporal_colocation:Event(present,be)
^1_Categorization:Item(be,_$qVar)
^1_Existance:Entity(be,_$qVar)

The goal of pattern matching is to glue (i.e. pattern-match) 
the above five clauses onto the original assertion that 
"yarn is a length of fibers".

The glueing fails. I want to get the answer that $qVar == length.
But I cannot match up ^1_Existance:Entity(be,_$qVar)
to ^1_Existance:Entity(be,length) --

Next, I want to match up ^1_Categorization:Category(be,yarn),
(from the question) to ^1_Categorization:Item(be,yarn) (from
the answer) but I can't. 

This asymmetry of the question and its answer has me blocked.

The root problem seems to be that both

_subj(be, _$qVar)
_obj(be, yarn)
and
_obj(be, _$qVar)
_subj(be, yarn)

are valid forms for the question. The second one should be
more common, but its not the one being generated. There 
should probably be a frame rule to reverse this order.

============
Step back; look at frame matching in a simpler example.

John threw a ball. 
^1_Body_movement:Agent(throw,John)
^1_Cause_motion:Theme(throw,ball)
^1_Transitive_action:Agent(throw,John)
^1_Temporal_colocation:Event(past,throw)
^1_Temporal_colocation:Time(past,throw)
^1_Body_movement:Body_part(throw,ball)
^1_Cause_motion:Cause(throw,John)
^1_Transitive_action:Object(throw,ball)


What did John throw?

^1_Body_movement:Agent(throw,John)
^1_Cause_motion:Theme(throw,_$qVar)
^1_Transitive_action:Agent(throw,John)
^1_Entity:Entity(what,_$qVar)
^1_Questioning:Message(what,_$qVar)
^1_Attributes:Entity(what,_$qVar)
^1_Possibilites:Event(hyp,throw)
^1_Body_movement:Body_part(throw,_$qVar)
^1_Cause_motion:Cause(throw,John)
^1_Transitive_action:Object(throw,_$qVar)


Remove "Questioning" and "what".

^1_Body_movement:Agent(throw,John)          -- OK match
^1_Cause_motion:Theme(throw,_$qVar)         -- OK _$qVar == ball.
^1_Transitive_action:Agent(throw,John)      -- OK match
^1_Body_movement:Body_part(throw,_$qVar)    -- OK _$qVar == ball
^1_Cause_motion:Cause(throw,John)           -- OK match
^1_Transitive_action:Object(throw,_$qVar)   -- OK _$qVar == bal

This type of relex frame-level setup, query massaging 
and node matching is implemented in FrameQuery.cc, FrameQuery.h
It seems to work, but hasn't undergone strenuous testing.

Testing
-------
Some test corpus material, and test results:

====
Mike threw a rock.
John threw a ball and a screwdriver.
John ate a peach.
What did John throw?

Relex matching provides two correct answers: 
_$qVar = ball, and _$qVar = screwdriver.
====

The book is red. What color is the book?
The color of the book is red. What color is the book?

Both of these fail on the simple pattern match.

====
Yarn is a length of fibers.
What is yarn?

Fails, as discussed above
====
Yarn is used to make cloth.
What is yarn used for?

_to-do(use, make)
_obj(use, yarn)
tense(use, present)
_subj(make, yarn)
_obj(make, cloth)
tense(make, infinitive)
HYP(make, T)
noun_number(cloth, uncountable)
noun_number(yarn, uncountable)

The assertion has a second parse, with "to" instead of "_to-do"

The question has three parses. The first is:

for(use, for)
_obj(use, yarn)
tense(use, present)
_amod(for, use)
_obj(for, _$qVar)
tense(for, present)
noun_number(yarn, uncountable)

All three parses contain _obj(use, yarn), and that's good.

Clearly, the pattern match here fails. All three parses contain
_obj(for, _$qVar) which cannot be matched to the original assertion.

All three contain either _amod(for, use) or _amod(for, be)
and these _amod's cannot be matched to the original assertion.

The frame situation is no better.  The assertion frame is:

^1_Transitive_action:Agent(make,yarn)
^1_Ingest_substance:Substance(use,yarn)
^1_Intentionally_create:Creator(make,yarn)
^1_Using:Instrument(use,yarn)
^1_Building:Created_entity(make,cloth)
^1_Causation:Affected(make,yarn)
^1_Arriving:Theme(make,yarn)
^1_Causation:Effect(make,cloth)
^1_Ingest_substance:Purpose(use,make)
^1_Cause_change:Cause(make,yarn)
^1_Possibilites:Event(hyp,make)
^1_Using:Purpose(use,make)
^1_Arriving:Goal(make,cloth)
^1_Temporal_colocation:Time(present,use)
^1_Temporal_colocation:Event(present,use)
^1_Transitive_action:Cause(verb,use)
^1_Transitive_action:Event(verb,make)
^1_Cooking_creation:Cook(make,yarn)
^1_Building:Agent(make,yarn)
^1_Cooking_creation:Produced_food(make,cloth)
^1_Intentionally_create:(make,cloth)
^1_Transitive_action:Object(make,cloth)
^1_Transitive_action:Object(use,yarn)
^1_Manufacturing:Product(make,cloth)
^1_Manufacturing:Factory(make,yarn)
^1_Cause_change:Entity(make,cloth)

The appearence of "cooking" is unexpected.  "Building" is odd 
Why not "manufacture" or "intentionally_create"?

"Ingest" is ... and odd way of saying that the yarn is used up...

  "What is yarn used for?"

Has the frameset below.  I've manually removed Questioning:Message, 
etc. as these are explicitly ignored for the question pattern match.
I've marked up each according to whether the frames echoed the
assertion:


^1_Using:Purpose(use,for)                         -- no match
^1_Ingest_substance:Substance(use,yarn)           == OK
^1_Using:Instrument(use,yarn)                     == OK
^1_Relative_time:Focal_occasion(for,for)          -- no match
^1_Relative_time:Landmark_occasion(for,use)       -- no match
^1_Temporal_colocation:Time(present,use)          == OK
^1_Temporal_colocation:Event(present,use)         == OK
^1_Temporal_colocation:Event(present_1,for)       -- no match
^1_Temporal_colocation:Time(present_1,for)        -- no match
^1_Ingest_substance:Purpose(use,for)              -- no match
^1_Transitive_action:Object(for,_$qVar)           -- no match
^1_Transitive_action:Object(use,yarn)             == OK

The word "for" seems to lie at the root of the problem.  
Lets try a different assertion:

  "Yarn is used for making cloth."

A clause by clause comparison shows that this doesn't match
the question any better then before. So pattern matching the
question fails here too.  

How similar are the two assertions? Lets compare relex output first;
ignoring tense, noun_number, which are correct, we have:

  "Yarn is used for making cloth."
_obj(use, yarn)
_amod(for, use)
_subj(make, for)
_obj(make, cloth)

  "Yarn is used to make cloth."
_to-do(use, make)
_obj(use, yarn)
_subj(make, yarn)
_obj(make, cloth)
HYP(make, T)

The only agreement is that both correctly state _obj(make, cloth)
and _obj(use, yarn)  However, _subj in both is confusing, and 
it seems hard to induce that the thing being used is also the 
input to the thing being made.

  "Yarn is used in making cloth."

_obj(use, yarn)
_amod(in, use)
_subj(make, in)
_obj(make, cloth)

  "Yarn is used in the making of cloth."

in(use, making)
_obj(use, yarn)
of(making, cloth)

The frame rules do not seem to introduce more commonality
between these; rather, they seem to diverge even more. Thus,
instead of the frames making things seem "more semantically
similar", they seem to do the opposite.

Now, some sort of fuzzy matching could be done here, since there
is clearly some non-zero overlap between all of these. Even more
so: it seems like the common parts of all of these ways of saying 
this capture the "underlying truth" the best. But without a large 
corpus, without lots of activation, and repeated similar but not 
identical restatements of the same ideas, I don't see any particularly
good ways of inducing that yarn is used to make cloth...


See:
http://www.cs.ualberta.ca/~lindek/papers.htm
Dekang Lin and Patrick Pantel. 2001. Discovery of Inference Rules for
Question Answering. Natural Language Engineering 7(4):343-360. [PDF][PS]


Query processing architectural issues:
--------------------------------------
Below are some architectural issues that have been given temporary
solutions, but need a better long-term solution.

-- How to distinguish rhetorical questions from queries that should
   be answered?  A block of input text may contain rhetorical questions,
   which should be ignored.

-- How should query processing be triggered?  What channel should be
   used for reply? Currently, all input to CogServer is via XML, which
   is parsed. If the parse is successful, no further processing is done.

   Query processing could be performed by a mind agent, but how should
   its activity be triggered, and what communictations channel should
   it use to post a reply?


Diary and Notes
---------------
Use special token to trigger mind agent. Per Ben, "DialogManager",
there are four such tokens:
-- query
-- statement
-- command
-- interjection

Right now, all four of these will be surrounded by an AssertionLink.
The query processor will look for  these, perform some basic sentence
analysis, and dispose of these as appropriate (i.e. generating an
appropriate reply).



