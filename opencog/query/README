
                  Query Processing/Pattern Matching
                          ----------------
               Linas Vepstas <linasvepstas@gmail.com>
                        Created 18 March 2008
                      Revised on 6 November 2014


This directory contains code that implements a subgraph isomorphism
algorithm, and then uses this algorithm to support several functions,
including query processing, graph-rewriting, and forward/backward
chaining.  The first part of the file describes the generic algorithm;
the second part describes some of its applications to query processing,
and graph-rewriting.

This code does not currently expose a "hypergraph query language" (HQL),
but doing so should not be hard to add. See the design notes below.

A simple example of one possible use of this code is shown in the file
"/examples/pattern-matcher/simple.scm".


Subgraph Isomorphism Discovery
------------------------------
Given a small (hyper-)graph and a bigger "universe" (hyper-)graph, the
subgraph isomorphism problem requires one to find the corresponding
smaller graph within the universe graph.  The smaller graph may include
one or more variable nodes or links; these denote variables which will
be given values (groundings): a variable will match any corresponding
node or link in the universe, as long as it occurs in the correct
location. Thus, subgraph matching defacto performs a kind of "variable
unification", and can be used to perform query processing, to "fill in
the blanks".

The subgraph matching algorithm implemented here is more or less
completely general.  The API to it provides for user-defined callbacks
that can be used to modify the search:

 * define what constitutes a 'match' (for individual nodes, links and
   clauses),
 * support for optional clauses (portions of the subgraph, which if
   found, are also returned; commonly used to reject certain types of
   patterns),
 * support for search-order ranking (re-ordering the incoming set,
   e.g. by priority), or even truncation of the incoming set.
 * support for the search start location (again, to potentialy limit
   the total search).
 * solution acceptance callback, to provide on-the-fly reporting, and
   limit the total number of groundings reported.
 * support for a back-tracking callback. During the search, the
   pattern matcher will typically need to backtrack; this callback
   allows user-defined algorithms to push and pop stacks as
   appropriate, as well.

An additional very important feature is support for 'virtual'
hypergraphs: those that are not pre-existing in the fixed universe 
(i.e. in the atomspace), but are only defined algorithmically, by a
predicate function that returns a yes/no answer about their existence.
An example would be a greater-than hypergraph that 'virtually' exists
only if a right-hand number is greater than a left-hand number.
Clearly, pre-loading the atomspace with every possible number, and
every possible number-pair is impossible; thus virtual hypergraphs
provide these relations on-the-fly, as needed.  The pattern matcher
is able to correctly find subgraphs that contain such virtual
hypergraphs.

Another important and perhaps under-appreciated function is the
ability to search through unordered links.  When the query subgraph
contains one or more unordered links, the subgraph isomorphism may
exist only for certain permutations of the unordered link.  Thus,
during search, all possible permutations of an unordered link must be
explored.  This increases the size of the search space by
combinatorial factors, and requires a significantly more complex
algorithm to deal with nested unordered links.

The algorithm itself performs an exhaustive search, and can therefore,
under certain circumstances, encounter a combinatorial explosion of
the search space, leading to very long run-times.  This is not usually
the case for most ordinary problems, but can occur for large problems
containing hundreds of unordered links and/or virtual nodes.

The algorithm performs a fair amount of pre-traversal setup and error
checking, such as finding the common variables that connect different
clauses together, and initializing and setting up maps to make traversal
easier.  This setup time is non-trivial.  Thus, for the simplest
patterns, it might be faster (and probably simpler) for the user to
obtain the desired graphs directly, instead of using the pattern
matcher.  The strength of the pattern matcher is its ability to handle
large, complex graphs with multiple variables interacting in difficult
ways (or even graphs with no constant nodes in them at all!)

The subgraph isomomorphism algorithm itself does not make use of or
require the atomspace: it simply traces connections between links by
traversing the incoming and outgoing sets. The atomspace is required
in only two places: to find a set of starting points for the search
(e.g. by finding all nodes of a given type), and as the location into
which new graphs are inserted (during graph-re-writing).

Clauses and Groundings
----------------------
The OpenCog hypergraph is most easily understood in terms of its
corresponding incidence graph (or "Levi graph"). This, in turn, is best
understood as a collection of trees formed by the "outgoing set" of an
OpenCog Link.  Each internal node of a tree is a link (as only links
have outgoing sets), and each leaf of a tree being a node (as nodes do
not have outgoing sets).  Thus, the outgoing set of an OpenCog Link
forms the downward-branching part of a tree.  The incidence graph is
then a collection of such trees, sharing common nodes or links.  The
incidence graph is an ordinary graph, not a hypergraph, and thus is
perhaps easier to visualize.

The pattern matcher is designed to search only for connected incidence
graphs.  This simplifies the algorithm without loosing any generality:
the user can always enumerate disconnected graphs multiplicatively.
This is both trivial and rarely desired.

Note: At this time, neither the OpenCog AtomSpace, nor the pattern
matcher support infinite, recursive subtrees.  That is, a given
incidence graph cannot/must-not have itself as a subtree.  This is
analogous to well-founded sets in set theory.  The tree formed by
outgoing sets must be finite.  Specifying a recursive subtree to the
pattern matcher risks infinite loops (although these could be
mitigated, if desired), and, likewise, infinite loops if inserted
into the atomspace.  Thus, the incidence trees must be finite
(although they do not need to be acyclic: different parts of the tree
may share common subtrees).

In the discussion below, and in the code, these trees are also called
"clauses".  More specifically, the input to the pattern matcher is
given by a list of clauses to be matched.

Consider the following example taken from a dependency parse of the
English language sentence "John threw a ball":

  _subj(throw, John)
  _obj(throw, ball)

There are two distinct graphical interpretations of this dependency
parse: the one commonly used in linguistics, and the one we want to
use here; they are not the same.  In linguistics, "throw" would be the
head word, and there would be labelled arrows pointing from the head
word to the subject and the object (the labels on the arrows being
_subj and _obj)

As a hypergraph, this consists of two trees.  The first tree has
"_subj" as the root, with "throw" and "John" as leaves underneath it.
Likewise, _obj is a tree. These two trees form the incidence graph of
the hypergraph. Note that these two trees share a common node:
"throw", that serves to join them together into one connected graph.

In OpenCog, links cannot have names; only nodes can. Thus, the actual
representation of the above parse, in OpenCog, will be:

   EvaluationLink
      PredicateNode "_subj"
      ListLink
         WordNode "throw"
         WordNode "John"

   EvaluationLink
      PredicateNode "_obj"
      ListLink
         WordNode "throw"
         WordNode "ball"

Here, the indentation level describes the tree structure. The links
and nodes are indicated by name: the nodes are always leaves of the
tree. The two trees or clauses above share a single, common node: that
for "throw".

For the above example, pattern matching can be used to form a simple
question-answering system, by "filling in the blanks".  The dependency
parse for the question "What did John throw?" can be written as:

  _subj(throw, John)
  _obj(throw, _$qVar)

By comparing to the previous graph, it is obvious that the variable
_$qVar can be directly matched to the word "ball", thus answering the
question.  This illustrates the simplest use of the system, as a
kind-of fill-in-the-blanks solver, for elementary-school word
problems: "What did John throw? John threw a ____."

The solution or answer is "ball". This is refered to as a "grounding"
for the "variable" "_$qVar".   The terminology of "grounding" and
"variable" is meant to be identical to the terminology commonly used
in textbooks on model theory, lambda calculus and first-order logic:
these are the very same ideas, expressed as hypergraphs.  In
particular, each "clause" or "tree" in the hypergraph incidence graph
corresponds to an "atomic expression" in a term algebra or in
first-order logic.  The search pattern or query pattern that the
pattern matcher matches against is an "expression" or "sentence"
containing variables.  The act of finding groundings for the variables
is identical to performing variable "unification".

The pattern matcher uses VariableNodes to represent variables. The
proper representation for the above query is thus:

   EvaluationLink
      PredicateNode "_obj"
      ListLink
         WordNode "throw"
         VariableNode "_$qVar"

The query pattern consists of one or more clauses, such as the above.
The query pattern is essentially a boolean-and of these clauses: all
of the clauses must be satisfied (with the exception of optional
clauses; see later discussion for this).  All clauses MUST contain at
least one variable: if they do not, they are constant clauses, and are
ignored.  This is because constant clauses are "trivial": the
groundings for them can only be themselves, trivially, and so nothings
needs be done.

The set of clauses defining a pattern must be connected by means of
common, shared variables.  A pair of clauses are connected if they
share a common variable. A set of clauses is connected if there is a
transitive path through all of them.  The need for this requirement
was mentioned before: disconnected graphs are always just a trivial
product of their connected components; thus, it is pointless to
explicitly support disconnected graphs.

At this time, the boolean-or of clauses is not supported. So far,
there has been no user demand for this feature.  A somewhat-related
feature, for optional clauses, is supported; however, this is
typically used to express patterns that should be rejected if they are
found.


Algorithm overview
------------------
The following sections present the algorithm details.

Terminology
-----------
The incidence graph of a hypergraph is called the "Levi graph".
Levi graphs are bipartite; although the algorithm does not make
use of this.

A solution that assigns a value to a variable is called a "grounding"
of that variable. Graphs that contain variables will sometimes be
called ungrounded graphs.

The Basic Algorithmic Idea
--------------------------
The basic idea is to treat the query as a graph, in which are embedded
some number of variables or unknowns. This query graph can be loosely
understood to be kind of like a predicate, in that the query is solved
only when the variables take on appropriate values, i.e. when the
variables are grounded.

The goal of query processing is to scan the collection of all knowledge,
(the "universe hypergraph"), looking for a subgraph that matches the
predicate. The nodes that fit where the unknowns would go are then the
answer to the query.

The problem of finding certain subgraphs within graphs is known as the
"subgraph isomorphism problem" or the "subgraph matching problem", and
one uses a "subgraph isomorphism algorithm" to find the match.

The input to the algorithm is a set of trees. Because each tree may have
several groundings, the algorithm maintains a stack to hold intermediate
groundings, as the universe is explored. A solution is declared when
every tree has been grounded. If no grounding is found, or if additional
solutions are to be searched for, the algorithm will backtrack to the
most recent unexplored part of the universe, poping the stack as it
backtracks. In this sense, the algorithm resembles a pushdown automaton.
Since pushdown automata are associated with context-free languages,
the subgraph isomorphism problem is essentially a problem in
recognizing a context-free language.


Currently Implemented Algorithm
-------------------------------
0) In the following, the word "atom" may refer to either a hypergraph
   node, or a hypergraph link. Corresponding to every hypergraph is
   an incidence graph. The atoms of a hypergraph are vertices of
   the incidence graph. The convention used here is that the incidence
   graph is a directed graph; thus, only hypergraph links have
   outgoing incidence graph edges; whereas hypergraph nodes have
   no outgoing incidence graph edges.

   The implemented algorithm makes direct use of the incidence
   graph, and only indirectly to the hypergraph. The insistence
   on making the incidence graph be a directed graph helps make
   traversal more direct and removes ambiguity.

   [OpenCog-specific remarks are in square brackets.  In OpenCog, the
   outgoing incidence graph edges are given by the "outgoing set" of
   the atom.]

1) Input consists a sequence of the roots of incidence trees, that is,
   of a list of subgraphs of the incidence graph that are trees.  Thus,
   by definition, the incidence tree root must be a hypergraph link,
   as hypergraph node cannot, by definition, have a non-trivial
   incidence tree under it.  Each tree is, by definition, directed.
   These trees are also refered to as "clauses", below [and in the code].
   This is because, in some cases, the tree can play the role of a
   logical clause. In some cases, the tree is also refered to as a
   a "predicate", although sometimes the whole collection of clauses
   is also called the predicate. Sorry for the confusion.

   Thus, for example: the clause _subj(row, Steve) has _subj at the
   root of the tree, with "row" and "Steve" as leaves.

   Distinct trees may have common vertices.  The common vertices
   act to join together the trees into a single, connected graph.
   Disconnected graphs are not allowed; the algorithm will fail to
   find and ground disconnected components.  The graph as a whole may
   contain loops (the decomposition into trees keeps the algorithm
   from having to explicitly accommodate loops).

   A list of the common, or shared, vertices is made; this list is
   used later in the algorithm, to find all trees connected to a
   specific vertex. [This list is implemented as
   PatternMatchEngine::root_map. The shared vertices are variables.]

   The universe graph may have any structure whatsoever; there are no
   limitations put on it, other than that it must be "well-founded",
   i.e. must not contain any infinite recursive graphs.

2) Input includes a list of the bound variables in the clauses.
   Thus, for example _obj(row,_$qVar) has _$qVar as the variable
   to be solved for. The list serves to explicitly identify the
   variables, so that they do not need to be computed or guessed.
   The designated variables need not be leaf vertices; that is, 
   variables may match links. There must be at least one variable,
   as otherwise the graph is constant, and there is nothing to be
   done.  The variables are called "bound" simply because they have
   been called out; whereas "free variables" are variables that may
   occur in the clauses, but, because they have not been identified
   to the algorithm, they will not be grounded, but will instead be
   treated as if they were constants.

3) Node equivalence is determined by means of a callback; the user
   may implement any notion at all of "equivalence".  In particular,
   the equivalence callback may be used as an alternate way to perform
   variable bindings, with the callback itself determining when a
   node is variable, and what the allowed bindings to it may be.
   The callback is free to consider node truth values, attention
   values, or anything else, in determining whether to accept or
   reject a candidate grounding.  Link equivalence is likewise
   governed by a callback.

   [The node equivalence callback is implemented in
   PatternMatchCallback::node_match(). The link equivalence callback is
   PatternMatchCallback::link_match().]

4) Pick the first tree. Get the type of the root atom of the
   first tree. Get a list of all atoms in the universe of this type.
   These are the "candidate groundings".  Iterate over this list.
   The iterator is the next step below (step 5).

   [This step is implemented in PatternMatchEngine::match(), which
   calls PatternMatchEngine::do_candidate() for each candidate root.
   The fetching of the list is provided by a user-defined algorithm.
   The default callback DefaultPatternMatchCB::peform_search()
   implements this by querying the atomspace for all atoms of a given
   type corresponding to some clause, and starting the search there.
   This default behaviour can be over-ridden with a user-dupplied
   callback.]

5) Initiate a recursive tree matching algorithm, comparing the
   incidence tree of the first clause to that rooted at the
   candidate grounding.

   First, the tree matching algo checks to see if the given
   node in the predicate is a variable; if so, then the match
   is considered to be successful. The node-match callback is
   invoked to decide whether this grounding is to be accepted;
   if it is, then the corresponding node in the universe is
   recorded as a grounding.

   If the clause itself is found in the universe, it is rejected.

   If the atom is a link, the link-match callback is invoked to
   determine whether its an acceptable grounding.

   The tree matching algorithm recurses to subtrees; recursion
   is terminated when a mismatch is found.

   [This step is implemented in PatternMatchEngine::tree_compare().]

   After an entire clause has been grounded, another callback, the
   clause-match callback, is called. This callback may reject the
   grounding of the clause as a whole.

6) Assuming a single tree has been successfully matched in the previous
   step, the next step is to find a clause that has not yet been
   grounded.  This is done by examining the list of all (variable)
   nodes that are shared between the most recently grounded clause,
   looking for an unsolved clause.

   [This is implemented in PatternMatchEngine::get_next_unsolved_clause()]

7) If an unsolved tree is found, then tree-matching, as described in
   step 5), resumes. However, the tree matching resumes at the shared
   node of the ungrounded tree. The ungrounded tree is recursively walked
   upwards, towards its root, with a tree match attempted at every stage.

   The upwards recursion uses a stack to track state; this is required
   in the case of there being multiple possible matches to a tree:
   after finding one match, the stack may be popped to explore other
   possible matches.  Push and pop callbacks are provided, in case the
   callback also needs to maintain stack state.

   If the upwards recursion reaches the root of the predicate, the
   predicate is now considered to be solved. Go to step 6), to find
   other unsolved predicates.

   [This is implemented by two routines: PatternMatchEngine::soln_up()
   and PatternMatchEngine::pred_up(). These two routines alternate
   calls to each other, by traversing the *incoming* set of the
   current node in the clause, and the candidate solution node.
   The incoming set takes one "upwards" in the tree.]

   [The stack of current state is maintained in PatternMatchEngine::
   pred_handle_stack, etc. These are pushed as an upwards(incoming)
   edge is explored, and popped when the edge is rejected.]

   [Partial solutions are recorded in PatternMatchEngine::var_grounding
   and PatternMatchEngine::clause_grounding.  These partial solutions
   must also be kept on stack, as a failed match at a later stage means
   that backtracking must be done. Since the partial solutions are used
   to find unsolved predicates, care must be taken that the partial
   solution is correct after backtracking: i.e. they must be popped
   as failed matches are encountered.]

   Note that multiple solution graphs may overlap.  Thus, if the
   universe contains the statement: "John threw a ball and a rock."
   and the query is "What did John throw?", then there are two
   valid subgraph matches: "John threw a ball" and "John threw
   a rock".  Both of these solutions contain a common subgraph,
   "John threw...", which must be reachable, and reconsidered,
   after one solution is proposed. In particular, this implies
   that the partial solution state must also be kept on stack,
   so that the backtracking can be performed to find other,
   overlapping solutions.

8) If no ungrounded tree is found, then the matching is complete.
   The full grounding is reported via callback.  The callback may
   indicate that the search be terminated, or that it continue to
   find other possible solutions.

   In addition to a list of clauses that MUST be grounded, the algorithm
   accepts a list of clauses that need only be optionally grounded. The
   optional list is exactly that: if no grounding is found, that's OK,
   and a solution is still reported for the must-list. The optional
   list can be used to implement pattern-rejection: so, for example,
   if a grounding for an optional clause is found, then the match as
   as a whole can be rejected. This kind of pattern-rejection is
   explicitly done with the crisp-boolean-logic callback.


Virtual Links
-------------
   Not mentioned above is a new whiz-bang feature: support for
   VirtualLinks, which are links that do not actually exist in the
   AtomSpace, but are evaluated on the fly, as needed.  The
   prototypical such link is GreaterThanLink, which evaluates to
   "exists" if the schema in it returns true; else it "doesn't
   exist".  That is, a GreaterThanLink will match in the pattern
   when its schema evaluates to true, behaving as if it existed in
   the AtomSpace, else it behaves as if it does not exist in the
   AtomSpace (and thus can't ground/match/unify).  This bit of
   fraudulent trickery requires a bit of work: in short, all other
   parts of the hypergraph are grounded first, leading to a possible
   combinatoric explosion of goundings; these are then passed through
   the virtual links to determine if a match has occured or not.
   The code to do this is in PatternMatch::recursive_virtual()
   (instead of in the engine proper, where you might expect it to be).

   Note that the preliminary grounding is done by removing all virtual
   links from the hypegraph. This will typically result in a set of
   hypergraphs that are no longer connected.  Each connected component
   is grounded, and then these are offered up to the virtual link,
   which either virtually (and so there is a match) or does not exist
   (so there is no match).  Note that having multiple disconnected
   compoents thus leads to a multiplicatively explosive search space
   to explore.

Unordered Links
---------------
   The use of unordered links within a pattern provides a special
   challange for the pattern matcher. This is because each possible
   permuation of an unordered link must be explored.  Consider, for
   example, the search pattern:

       AndLink
          SetLink
             VariableNode $a
             VariableNode $b
          ListLink
             VariableNode $a
             ConceptNode "fizz"

   If the universe contains the graphs:

       SetLink
          ConceptNode "dribble"
          ConceptNode "bubble"

       ListLink
          ConceptNode "bubble"
          ConceptNode "fizz"

   then one must consider that $a might be grounded by "bubble" (and
   so a match is found), or that $a could have been grounded by
   "dribble" (although this is not consistent with the ListLink, and
   so no overall match exists).  That is, all possible permutations of
   the SetLink must be considered when searching for groundings. This
   can lead to a combinatoric explosion.

   Backtracking through unordered links is a challenge. To better
   understand this challange, there are four distinct scenarios that
   can occur during pattern matcing.  These are:

   A) One is at the bottom, and is searching upwards, and encounters
      an unordered link as a parent of the current atom.

   B) One is at the bottom, moving upwards, and during the (downward)
      tree_compare's that must be performed at each stage, there is
      an unordered set somwhere in a subtree.

   C) Situations A) and B) can occur in a nested fashion, so that an
      unordered link may have another unordered link inside of it.
      All of this is happening within the smae clause.

   D) There may be other unordered links in other clauses (possibly
      sharing variables with the unordered links in this clause).

   Note that, for situation A), as one continues to move upwards, the
   downward tree-compare effectively looks like situation B).

   Situation D) is easily dealt with by using the existing
   backtracking infrastructure, and so presents no new challanges.

   Situations A, B and C are currently (Nov 2014) only paritally
   handled, and are buggy.  Its all very confusing. See github bug
   #1091 for details.


Open Questions
--------------
In many ways, the above algorithm resembles that of a recursive descent
parser.  However, it does a *lot* of backtracking during its solution
search. It is throughly unclear as to whether the hypergraph
pattern-matching problem can be reformulated to resemble an LL(k)
grammar, so that linear-time predictive parsing techniques can be used.

In many ways, the above algorithm resembles a boolean satsifiability
problem, except that, instead of having a two-valued true/false logic,
it is a many-valued logic (with each variable ranging over the
universe of allowed values for that variable).  Can any kind of a
modern boolean-SAT algorithm be applied to solve this problem quickly,
efficiently?  Is there a way of cribbing ideas from the DPLL algorithm
to help solve this?  This is entirely unclear to me...


Summary
-------
The above describes a specific implementation of a subgraph matching
algorithm. It is generic, in that it makes no reference to the
specifics of the actual data layout, or of node equivalences in the
data.  The only restriction made is that the input, query graph,
has been decomposed into a set of trees.

[On OpenCog, the entire implementation is in PatternMatchEngine.[h, .cc].]

Example Code
------------
The test/query directory contains several test cases checking on this
functionality. The BigPatternUTest test case is a small, simple, clear
example of using the simple forward chainer.


Ranking; Approximate matching; Crisp and Fuzzy Logic
----------------------------------------------------
The final decision on matching to a given query pattern is delegated
to a callback. This allows for considerable flexibility in controlling
matching for hypergraphs that represent crisp logic statements, or those
that use probalistic logic, or for ranking matches by quality.

Callbacks are provided to accept or reject individual node and link
groundings, and to accept of reject the grounding of individual clauses.
In addition, the "optional clause" mechanism provides a means of
pattern rejection. This can be done by specifying the pattern to be
rejected as "optional": thus, if it is not found, a solution is reported;
but if it is found, then the callback can reject the solution.
The callback is free to examine truth values, STI/LTI, etc. in
accepting or rejecting any given grounding.  Push and pop callbacks
are provided to help maintain state on a stack, to deal with partial
matches, if needed.

The "optional" mechanism can also be used to implement approximate
matching, by specifying the parts of the graph that would be "nice
to match", but not strictly required.

Alternately, the ranking/acceptance/rejection of the solution subgraph
can be performed in a post-processing stage.  This may be an easier
approach for many cases.

At this time, two generic callbacks are provided:

*) The DefaultPatternMatchCB. This callback implements node and link
   match methods that accept only strict node/link matches, unless a
   node is of type VariableNode, in which case the match is also
   accepted. No effort is made to consult truth values or other atom
   properties to determine a match.

*) The CrispLogicPMCB. This callback implements a crisp boolean logic
   matching scheme. If a clause is matched, then the grounding must
   have a truth value of greater than 0.5 to be considered a match.
   By contrast, optional clauses must have a truth value of less than
   0.5 to be acceptable; optional clauses are interpreted as negations:
   they can be absent, or, if present, they must be false.


Forward Chainer
---------------
The PattnerMatch::imply() method implements a critical component for a
forward chainer: it is able to accept, as input, an ImplicationLink, and
return as output, a ListLink of the implicands. An ImplicationLink is
basically an IF ... THEN ... statement, expressed as an OpenCog hypergraph.

Properly, one writes "IF ... THEN ..." as "IF predicate THEN implicand".
The predicate is presumed to contain VariableNodes, while the implicand
is a hypergraph making used of those VariableNodes.  The predicate is
run through the pattern-matching engine. When groundings for the
variables are found, then a hypegraph is created based on the implicand,
using the grounded values found.  Because there may be more than one
grounding, a ListLink of all grounded implicands is returned.

Thus, the PattnerMatch::imply() method can be used to implement a
simple forward-chainer. For example, one may create a collection of
ImplicationLinks. Then, calling each in turn, from a loop, will cause
cause each to be evaluated. Thus, N iterations of the loop is equivalent
to chaining N levels deep.


Hypergraph Query Language (HQL)
-------------------------------
A "hypergraph query language" is a language that allows queries to be
expressed as strings. Given *any* way of writing down a hypergraph as
a string, a hypergraph query language can be trivially formed by adding
variables to the expression, in exactly the same way that one adds
variables to logic predicates, lambda calculus, etc.  In order to feel
comfortable to programmers, the query language should maintain the
outward form of SQL, SPARQL, RQL, etc.

So, for example, a hypergraph might be written as a list
of links, and their contents:

  <hypergraph> := { <link-type> <atom> <atom> ... <atom>.
                    <link-type> <atom> <atom> ... <atom>.
                    ...
                    <link-type> <atom> <atom> ... <atom>.
                  }

Here, <atom> is understood to refer to a specific, constant atom.
Let ?var be a variable.  Then define <vatom> as

  <vatom> :=  <atom> | ?var

That is, a vatom is a constant atom, or a variable. A hypergraph
with variables in it is then

  <v-hypergraph> := { <link-type> <vatom> <vatom> ... <vatom>.
                      <link-type> <vatom> <vatom> ... <vatom>.
                      ...
                      <link-type> <vatom> <vatom> ... <vatom>.
                    }

An HQL query, resembling the syntax used in SQL or SPARQL, is then

  SELECT ?var-a ?var-b ... ?var-z WHERE <v-hypergraph>;

So, for example, the hypergraph for

    _subj(throw, John )
    _obj(throw, ball)

is somewhat complicated to write down, but vaguely resembles

    { ?x WORD_NODE John.
      ?y WORD_NODE throw.
      ?z WORD_NODE ball.
      RELEX_LINK _subj ?y ?x.
      RELEX_LINK _obj  ?y ?z.
    }

The query to determine what John threw would then be:

  SELECT ?item WHERE
    { ?x WORD_NODE John.
      ?y WORD_NODE throw.
      RELEX_LINK _subj ?y ?x.
      RELEX_LINK _obj  ?y ?item.
    }

There is currently no code that will actually parse such strings, and
return the query results, although, in principle, writing such code
would not be hard.  In practice, its a little more subtle than that:
we've glossed over the idea that truth values could be queryable, or
that truth values would need to have some minimum/maximum value, or
that atom types could be queryable.  Also, the representation of RelEx
expressions in OpenCog is considerably more complicated than the above.

To overcome these difficulties, it is strongly suggested (would make
sense) to create the actual query language from within the scheme
bindings. This is because it is straight-forward, in scheme, to create
the "syntactic sugar" to hide RelEx intricacies, and hide many of the
other nasty details, while keeping a nice and simple interface for the
user.

What is currently implemented is "English as a query language". That is,
queries are posed in English, such as "What did John throw?". These are
parsed by RelEx and turned into OpenCog hypergraphs with embedded query
variables (_$qVar) in them.  The code in this directory will process
these queries, and return values for _$qVar.

Thus, at least for RelEx-based queries, there is no need for HQL, as
using the English language is (a lot) easier than writing a formal
HQL query.  In this sense, English is the "best" query language, and
it is supported.


Foreach iterators
-----------------
The algorithm makes heavy use of "foreach" iterators to walk the
incoming and outgoing edges of an atom.  The "foreach" mechanism
has multiple advantages over other techniques, and it is important
to understand these.

On the other hand, given that this is C++ and not C, the correct
solution is almost surely to re-write the for-eachs as C++ iterators,
which offers the same advantages as foreach, but has a more mundane
programming paradigm.

A) The details of the Atom.h incoming and outgoing sets are abstracted.
   Thus, while the outgoing set uses std:vector, the incoming set uses
   a simple linked list. This detail is immaterial to the "foreach" user,
   as both look the same. The only requirement is that each edge is visited
   exactly once.

B) The foreach abstraction makes multi-threaded implementation,
   including mutex locking, much easier. In particular, the semantics
   of atomic locking of a foreach traversal is much simpler than complexity
   of trying to lock a naked linked list for read-only or read-write
   traversal.

C) The foreach abstraction can (and will) have performance that is
   equal to a for-loop iteration over an array or linked list. This
   is because, when the set to be iterated over is a simple list or
   array, the foreach iterator can be implemented as an inline function.
   Modern compilers are able to inline such functions correctly,
   and optimize the result, providing performance equivalent to
   a raw for-loop iteration.

D) The foreach abstraction allows complex iterators to be implemented.
   Thus, the foreach abstraction eliminates the data copying associated
   with naive "filters", and thus can offer superior space *and* time
   performance over filters. For example, consider a long linked list
   consisting of many types of atoms, and one wants to perform a certain
   operation only on a specific type of atom. Traditional "filters"
   would make a copy of the list, including only the desired atom
   types in the copied list. This requires significant overhead:
   nodes must be copied, iterated over, and then freed.  The foreach
   abstraction allows a zero-copy filter to be implemented: the
   callback is invoked only for those nodes that match the filter
   criteria.


TODO
----
 * Enhancement: Add support for VariableLink, so that, for example,
   (VariableLink $R (VariableNode $A) (VariableNode $B)) matches
   any arity-2 link (as long as the type constraints are obeyed).

 * Performance improvement: Steal an idea from DPLL, viz unit_propagate.
   That is, start with those clauses that have only a single variable
   in them, ground that, and propagate.  Not sure, I think this could
   should improve run-time.  Perhaps there are other ideas to steal,
   e.g. from zChaff?

   Anyway, the next clause to be selected is chosen by
   get_next_untried_clause(); there is a XXX note in there about this.

 * Enhancement: Add support for OrLink's in the pattern: viz: having
   partly matched some fraction of the pattern, allow the OrLink to
   specify several different sub-parts that are acceptable matches.
   That is, the pattern has 'fixed' regions, and 'variable' regions,
   or, 'required' regions and 'alternatively-required' regions.  It
   seems like these should be nestable.  This would have to behave
   like an exclusive-or: one MUST match one-and-only-one of the
   sub-parts.  Berhaps this could be done by extending the 'optional'
   part of the matcher?

 * Enhancement: Add support for IfLink, which would have the semantics
   'if (some-condition-during-search) then match-this else match-that'
   This would need to be an extension of GreaterThanLink, which has
   the semantics of 'if (some-condition-during-search) then
   trivial-always-match else trivial-impossible-match.'

 * Enhancement: allow user to bind a handle name to a subset of the
   match. This would be handy to reduce the verbosity of writing down
   the consequenct part (e.g. if we matched clauses a,b,c, then the
   output could be just clause b only, and it would be nice to just say
   'clause b' instead of spelling it out.)

 -------------------------- END OF FILE ------------------------
