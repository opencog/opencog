{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE FlexibleContexts           #-}
module OpenCog.Lojban.Syntax.Types where

import Prelude hiding (id,(.),(<*>),(<$>),pure,(*>),(<*),foldl)


import Data.List (partition,isPrefixOf,isSuffixOf,nub,any,intercalate)
import Data.Maybe (fromJust)
import qualified Data.Map as M

import qualified Iso

import OpenCog.AtomSpace
import OpenCog.Lojban.Util

import Control.Monad.RWS

import qualified Data.ListTrie.Patricia.Set.Ord as TS

type StringSet = TS.TrieSet Char

--The firs element of the tuple is a Atom that is part of the main Sentence/Link
--The List are other atoms which have to be added to the Atomspace or are needed for printing
type Tag = String

--Sumtis are tagged atoms where the tag descripes their place in the predicate
type Sumti = Tagged Atom

--Selbri are Atoms with a TruthVal they can also be tagged with a strength modifier
type Selbri = (TruthVal,Atom) --STring represents TV

type Tagged a = (a,Maybe Tag)

--LCON is the type for logical connectives
type LCON = (Maybe String,(String,Maybe String))

--Con possible contains a Logical Connective and one based on a predicate
type Con = (Maybe LCON,Maybe (Tagged Selbri))

--A Bridi consits of a some sumti/arguments in the front
--Then Maybe a Tense
--Then Maybe a Negation
--Then the Selbri/Predicate
--finally some more sumti/arguments
type Bridi = ([Sumti],((Maybe Atom,(Maybe String,Tagged Selbri)),[Sumti]))


--The Reader Contents
--cmavos : A map of wordlists given by their grammaticall class
--gismus : A wordlist of all gisms
--bai    : A mapping from bai to their corresponding gismu
--seed   : A seed for random generation
data WordList = WordList { cmavos :: M.Map String StringSet
                         , gismus :: StringSet
                         , bai    :: SynIso String String
                         }
--The State
--sFlags : A list of flags then can be used to pass information along
--sAtoms : A list of Atoms that will be generated by parsing
--sText  : The actuall text to be parsed
type Flag = String
data State = State { sFlags :: [Flag]
                   , sAtoms :: [Atom]
                   , sText :: String
                   , sSeed   :: Int
                   } deriving Show

--They Iso we are using
--We use a RWST monad over (Either String) for failurs
--currently the writer part is unused
type SynIso a b = Iso.SynIso (RWST WordList () State) a b
type Syntax a   = SynIso () a

--The parser Requirse that the State is a SyntaxState
instance Iso.SyntaxState State where
    getText = sText
    addText str sta = sta {sText = str ++ (sText sta)}
    setText str sta = sta {sText = str}
