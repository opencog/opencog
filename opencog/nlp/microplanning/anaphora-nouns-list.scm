; loading additional dependency
(use-modules (oop goops))
(load "anaphora-noun-item.scm")

; -----------------------------------------------------------------------
; <nouns-list> -- A class containing a list of <noun-item>
;
; A <nouns-list> is generated by extracting all noun nodes from the links
; in a chunk.  This class contains a bunch of method for acting on such
; a list.
;
(define-class <nouns-list> ()
	(lst #:init-value '())
	(assoc-table #:init-value '())
)

; -----------------------------------------------------------------------
; get-length -- Get the length of a <nouns-list>
;
(define-method (get-length (nl <nouns-list>))
	(length (slot-ref nl 'lst))
)

; -----------------------------------------------------------------------
; add-noun-item -- Add a <noun-item> to the <nouns-list>
;
(define-method (add-noun-item (nl <nouns-list>) (ni <noun-item>))
	(slot-set! nl 'lst (append (slot-ref nl 'lst) (list ni)))
)

; -----------------------------------------------------------------------
; get-noun-item -- Get a <noun-item> from the <nouns-list> base on 'index'
;
(define-method (get-noun-item (nl <nouns-list>) (index <integer>))
	(list-ref (slot-ref nl 'lst) index)
)

; -----------------------------------------------------------------------
; get-sublist -- Returns a new <nouns-list> that is a sublist of the original
;
; Note that objects in Scheme are passed by reference, so that means the
; <noun-item> in the new sublist is the same as the original.  Modifying
; a <noun-item> in one list will also appear changed in the other.
;
(define-method (get-sublist (nl <nouns-list>) (start-index <integer>) (end-index <integer>))
	(define new-list (make <nouns-list>))
	(slot-set! new-list 'lst (sublist (slot-ref nl 'lst) start-index end-index))
	new-list
)

; -----------------------------------------------------------------------
; get-chunk-sublist -- Get a new sublist bases on 'chunk-index' of each <noun-item>
;
(define-method (get-chunk-sublist (nl <nouns-list>) (chunk-index <integer>))
	; find subset of nouns-list that share the same chunk number
	(define start-index (list-index (lambda (n) (= chunk-index (get-chunk-index n))) (slot-ref nl 'lst)))
	(define end-index (list-index (lambda (n) (< chunk-index (get-chunk-index n))) (slot-ref nl 'lst)))

	; makes it so that we will return an empty subset if a chunk does not need to be changed
	; (eg. if a chunk somehow has no noun)
	(if (not start-index)
		(set! start-index (get-length nl))
	)
	; if we have reached the end of the set
	(if (not end-index)
		(set! end-index (get-length nl))
	)

	(get-sublist nl start-index end-index)
)

; -----------------------------------------------------------------------
; get-chunk-link-sublist -- Get a new sublist bases on the 'chunk-index' and 'link-index'
;
(define-method (get-chunk-link-sublist (nl <nouns-list>) (chunk-index <integer>) (link-index <integer>))
	(define chunk-sublist (get-chunk-sublist nl chunk-index))
	
	; find subset of chunk-sublist that share the same link number
	(define start-index (list-index (lambda (n) (= link-index (get-link-index n))) (slot-ref chunk-sublist 'lst)))
	(define end-index (list-index (lambda (n) (< link-index (get-link-index n))) (slot-ref chunk-sublist 'lst)))

	; makes it so that we will return an empty subset if a link does not need to be changed
	; (eg. if a link does not contain a noun)
	(if (not start-index)
		(set! start-index (get-length chunk-sublist))
	)

	; if we have reached the end of the subset
	(if (not end-index)
		(set! end-index (get-length chunk-sublist))
	)
	
	(get-sublist chunk-sublist start-index end-index)
)

; -----------------------------------------------------------------------
; find-by-proc -- Find the first <noun-item> where 'proc' return #t
;
; 'proc' needs to be a normal Scheme procedure (not <generic>) but must
; accept a <noun-item> as the parameter.
;
(define-method (find-by-proc (nl <nouns-list>) (proc <procedure>))
	(find proc (slot-ref nl 'lst))
)

; -----------------------------------------------------------------------
; construct-associations -- Construct the association table between items
;
; Given two <noun-item>, they are associated if they will ended up as
; the same word in the final sentence.  For example, given a chunk
;
;    EvaluationLink eat@123 dog@123 apple@123
;    InheritanceLink dog@123 big@123
;    EvaluationLink drink@123 dog@123 water@123
;
; we will have a <nouns-list> of
;
;    (dog@123, apple@123, dog@123, dog@123, water@123)
;
; If the final sentence is
;
;    "The big dog eats the apple and drinks the water"
;
; then all <noun-item> of "dog@123" are associated.  However, if the final
; sentence is
;
;    "The big dog eats the apple, and the dog then drinks the water"
;
; then only the first two <noun-item> of "dog@123" are associated with
; each other.
;
; Ideally this would require knowing what the final sentence is like.
; However, since SuReal will return multiple possible sentences, this is
; not feasible (both associations above could happen).
;
; Instead, this algorithm will assume any <noun-item> A is associated with
; the first <noun-item> B in the chunk that is not in an InheritanceLink,
; unless A is itself in a non-InheritanceLink.  This pushes all adjectives
; to be associated with the first instance of the noun in the sentence.
;
(define-method (construct-associations (nl <nouns-list>))
	(define last-chunk-index (get-chunk-index (last (slot-ref nl 'lst))))
	(define (helper chunk-index)
		(define sub (slot-ref (get-chunk-sublist nl chunk-index) 'lst))
		
		; find the first <noun-item> with same node and not in an InheritanceLink, and update the table
		(define (update-assoc-table ni)
			(define target
				; target is itself if 'ni' is already in a non-InheritanceLink
				(if (not (equal? (cog-type (get-orig-link ni)) 'InheritanceLink))
					ni
					(find
						(lambda (x)
							(and
								(equal? (get-noun-node x) (get-noun-node ni))
								(not (equal? (cog-type (get-orig-link x)) 'InheritanceLink))
							)
						)
						sub
					)
				)
			)

			; only associate if they are in two different links (avoiding reflexive associating with each other)
			(if (and target (not (equal? (get-orig-link ni) (get-orig-link target))))
				; add target to ni's association
				(slot-set! nl 'assoc-table (assoc-set! (slot-ref nl 'assoc-table) ni target))
			)
		)
		
		(for-each update-assoc-table sub)
		
		(if (< chunk-index last-chunk-index)
			(helper (+ 1 chunk-index))
		)
	)

	(if (>= last-chunk-index 0)
		(helper 0)
	)
)

; -----------------------------------------------------------------------
; get-association -- Get the list of association to the <noun-item>
;
(define-method (get-association (nl <nouns-list>) (ni <noun-item>))
	(assoc-ref (slot-ref nl 'assoc-table) ni)
)

; -----------------------------------------------------------------------
; is-modified? -- Check a <noun-item> to see if it is modified
;
; Modified means things like adjectives, so it will check the chunk in
; which the <noun-item> is in for InheritanceLink which contains the
; same noun ConceptNode.
;
; If passed a <noun-item> that is in the modifier itself, will also
; return #t.
;
(define-method (is-modified? (nl <nouns-list>) (ni <noun-item>))
	(or
		; if some other <noun-item> is associated with this one, then it is modified
		(any
			(lambda (at) (equal? ni (get-association nl at)))
			(slot-ref nl 'lst)
		)
		; if there's an association, then the <noun-item> is modified
		(get-association nl ni)
	)
)

; -----------------------------------------------------------------------
; is-ambiguous? -- Check a <noun-item> to see if it is ambiguous if pronoun-ed
;
; Check the neighboring subject/object/indirect-object and see if changing
; <noun-item> to pronoun will be ambiguious.
;
(define-method (is-ambiguous? (nl <nouns-list>) (ni <noun-item>))
	(define index (list-index equal? (slot-ref nl 'lst) (circular-list ni)))
	(define min-index (max 0 (- index 3))) ; inclusive
	(define max-index (min (get-length nl) (+ index 3))) ; exclusive

	; check how many pronouns in subset equals ni's (except itself)
	(> (count
		(lambda (n) (and (not (equal? 'InheritanceLink (cog-type (get-orig-link n)))) ; exclude modifying link from amod-rule
				 (not (equal? (get-noun-node n) (get-noun-node ni)))
				 (string=? (get-base-pronominal n) (get-base-pronominal ni))))
		(sublist (slot-ref nl 'lst) min-index max-index)
	   )
	   0
	)

	; TODO sometimes it is OK depends on the main subject (current and previous sentence)
	; (eg.  John helped Sam to prepare his project.)
	; (eg.  John helped Sam to feed himself.)
)

; -----------------------------------------------------------------------
; is-ancient? -- Check if <noun-item> was mentioned too long ago
;
; Check if <noun-item> was mentioned more than 3 sentences ago, makes it
; difficult to understand if changed to a pronoun.
;
(define-method (is-ancient? (nl <nouns-list>) (ni <noun-item>))
	(define index (list-index equal? (slot-ref nl 'lst) (circular-list ni)))
	(define (get-last-time ind)
		(if (< ind 0)
			'()
			; get the noun-item at index 'ind'
			(let ((n (list-ref (slot-ref nl 'lst) ind)))
				(if (and (equal? (get-noun-node n) (get-noun-node ni))			; same noun instance
					 (not (equal? 'InheritanceLink (cog-type (get-orig-link n)))))	; not a modifying link (amod-rule)
					n
					(get-last-time (- ind 1))
				)
			)
		)
	)
	(define last-occurrence (get-last-time (- index 1)))

	; a noun is ancient if appearing more than 3 sentences ago, or not at all
	(or (null? last-occurrence) (< (+ 3 (get-chunk-index last-occurrence)) (get-chunk-index ni)))
)

; -----------------------------------------------------------------------
; is-first-time? -- Check if <noun-item> was mentioned the first time
;
(define-method (is-first-time? (nl <nouns-list>) (ni <noun-item>))
	(define all-occurrences (filter (lambda (n) (equal? (get-noun-node n) (get-noun-node ni))) (slot-ref nl 'lst)))
	
	(or
		(equal? (car all-occurrences) ni)
		(equal? (car all-occurrences) (get-association nl ni))
	)
)

; -----------------------------------------------------------------------
; update-anaphora-safety -- Update the safety flags in a <noun-item>
;
; Check all <noun-item>s in the <nouns-list> against each other and update
; the 'pronoun-safe' & 'lexical-safe" flag as neccessary, to indicate
; whether the noun usage in <noun-item> can be safely changed to a pronoun
; or lexical noun phrase without causing confusion to the final sentence.
;
(define-method (update-anaphora-safety (nl <nouns-list>))
	(define (is-pronoun-safe? ni)
		(not (or (is-ancient? nl ni) (is-ambiguous? nl ni) (is-modified? nl ni)))	
	)
	(define (is-lexical-safe? ni)
		(not (is-first-time? nl ni))	
	)

	(for-each
		(lambda (n) (set-pronoun-safe! n (is-pronoun-safe? n)))
		(slot-ref nl 'lst)
	)
	(for-each
		(lambda (n) (set-lexical-safe! n (is-lexical-safe? n)))
		(slot-ref nl 'lst)
	)
)

; -----------------------------------------------------------------------
; populate-nouns-list -- Populate the <nouns-list> by extracting from 'chunks'
;
; Check all the chunk in 'chunks' and extract nouns.  Create the
; corressponding <noun-item> and add it to the list.  Update the safety
; flags after the list is populated.
;
(define-method (populate-nouns-list (nl <nouns-list>) (chunks <list>))
	(define atom-index 0)

	; for each chunk
	(for-each
		(lambda (c chunk-index)
			; for each link in a chunk
			(for-each
				(lambda (link link-index)
					(set! atom-index 0)
					; for each node in a link
					(for-each
						(lambda (node)
							(if (word-inst-is-noun? (r2l-get-word-inst node))
								(add-noun-item
									nl
									(make <noun-item>
										#:noun-node node
										#:orig-link link
										#:atom-index atom-index
										#:link-index link-index
										#:chunk-index chunk-index
									)
								)
							)
							(set! atom-index (+ 1 atom-index))
						)
						(cog-get-all-nodes link)					
					)
				)
				c
				(iota (length c)) ; generate link-indices
			)				
		)
		chunks
		(iota (length chunks)) ; generate chunk-indices
	)

	; build the association table
	(construct-associations nl)

	; determine pronoun and lexical safety bases on the current set of chunks
	(update-anaphora-safety nl)
)
