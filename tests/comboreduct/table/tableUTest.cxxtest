/** tableUTest.cxxtest --- 
 *
 * Copyright (C) 2011 OpenCog Foundation
 *
 * Author: Nil Geisweiller <nilg@desktop>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */
#include <opencog/comboreduct/table/table.h>
#include <opencog/comboreduct/table/table_io.h>

using namespace opencog;
using namespace combo;
using namespace std;

const string olabel = "happiness";
const string label1 = "price";
const string label2 = "temperature";
const string tableUTest_dir = string(PROJECT_SOURCE_DIR) + "/tests/comboreduct/table/";

class tableUTest : public CxxTest::TestSuite
{
private:
    void testIStreamTable(const string& ts, ITable& it, OTable& ot,
                          bool has_header,
                          const string& target_feature = string(),
                          const string& timestamp_feature = string(),
                          const vector<string>& ignore_features = vector<string>())
    {
        std::cout << "\n----------------------------" << std::endl;

        stringstream ss(ts);
        Table tab;
        istreamTable(ss, tab, target_feature, timestamp_feature, ignore_features);
        ITable& it_test = tab.itable;
        OTable& ot_test = tab.otable;

        std::cout << "it =" << std::endl;
        std::cout << it << std::endl;
        std::cout << "it_test =" << std::endl;
        std::cout << it_test << std::endl;
        std::cout << "ot =" << std::endl;
        std::cout << ot << std::endl;
        std::cout << "ot_test =" << std::endl;
        std::cout << ot_test << std::endl;
        TS_ASSERT_EQUALS(it, it_test);
        TS_ASSERT_EQUALS(ot, ot_test);
    }
public:
    
    tableUTest()
    {
        logger().setPrintToStdoutFlag(true);
        logger().setLevel(Logger::DEBUG);
    }

    void test_TruthTable()
    {
        vertex_seq o{id::logical_true, id::logical_false};
        OTable ot(o);
        ITable it(vector<type_node>(2, id::boolean_type));
        it.push_back({id::logical_true, id::logical_false});
        it.push_back({id::logical_false, id::logical_true});
        testIStreamTable("1,1,0\n"
                         "0,0,1\n", it, ot, false);
    }

    void test_ContinTable()
    {
        vertex_seq o{10.1, 6.5};
        OTable ot(o);
        ITable it(vector<type_node>(2, id::contin_type));
        it.push_back({0.4, 244.2});
        it.push_back({9.5, 4.2});
        testIStreamTable("10.1,0.4,244.2\n"
                         "6.5,9.5,4.2\n", it, ot, false);
    }

    void test_ContinTable_type_inference()
    {
        vertex_seq o{0, 1, 10.1, 6.5};
        OTable ot(o);
        ITable it(vector<type_node>(2, id::contin_type));
        it.push_back({1.0, 1.0});
        it.push_back({0.0, 1.0});
        it.push_back({0.4, 244.2});
        it.push_back({9.5, 4.2});
        testIStreamTable("0,1,1\n"
                         "1,0,1\n"
                         "10.1,0.4,244.2\n"
                         "6.5,9.5,4.2\n", it, ot, false);
    }

    void test_ContinTableLabels()
    {
        vertex_seq o{0, 10.1, 6.5};
        OTable ot(o, olabel);
        ITable it(vector<type_node>(2, id::contin_type));
        it.push_back({1.0, 1.0});
        it.push_back({0.4, 244.2});
        it.push_back({9.5, 4.2});
        vector<string> il{label1, label2};
        it.set_labels(il);
        testIStreamTable("happiness,price,temperature\n"
                         "0,1,1\n"
                         "10.1,0.4,244.2\n"
                         "6.5,9.5,4.2\n", it, ot, true);
    }

    void test_EnumTableLabels()
    {
        vertex_seq o{enum_t("sad"), enum_t("bored"), enum_t("super-happy")};
        OTable ot(o, olabel);
        vector<type_node> itypes({id::contin_type, id::contin_type, id::boolean_type});
        vector<string> il{label1, label2, "truth"};
        ITable it(itypes, il);
        it.push_back(vertex_seq({1, 1, id::logical_false}));
        it.push_back(vertex_seq({0.44, 244.2, id::logical_true}));
        it.push_back(vertex_seq({9.5, 4.2, id::logical_false}));
        testIStreamTable("happiness,price,temperature,truth\n"
                         "sad,1,1,0\n"
                         "bored,0.44,244.2,T\n"
                         "super-happy,9.5,4.2,F\n", it, ot, true);
    }

    void test_filterITable()
    {
        std::cout << "\n----------------------------" << std::endl;
        vector<string> lbs{"truc" ,"trac"};
        ITable it(vector<type_node>(2, id::boolean_type), lbs);
        it.push_back({id::logical_true, id::logical_false});
        it.push_back({id::logical_false, id::logical_true});
        vertex_seq o{id::logical_true, id::logical_false,};
        // ignore second argument trac
        vector<arity_t> args{0};
        ITable fit_it = it.filtered(args);
        OTable ot(o, "troc");
        stringstream ss;
        ostreamTable(ss, fit_it, ot);
        cout << "result: filterITable" << endl;
        cout << ss.str();
        cout << "fit_it:" << endl;
        cout << fit_it;
        cout << "ot:" << endl;
        cout << ot;
        TS_ASSERT_EQUALS(ss.str(),
                         "troc,truc\n"
                         "1,1\n"
                         "0,0\n");
    }

    void test_filterCTable()
    {
        std::cout << "\n----------------------------" << std::endl;
        vector<type_node> ts(2, id::boolean_type);
        vector<string> lbs{"truc" ,"trac"};
        ITable it(ts, lbs);
        it.push_back({id::logical_true, id::logical_false});
        it.push_back({id::logical_false, id::logical_true});
        vertex_seq o{id::logical_true, id::logical_false,};
        OTable ot(o, "troc");
        Table table(ot, it);
        // Generate CTable
        CTable ctable = table.compressed();
        // ignore second argument trac
        vector<arity_t> args{0};
        CTable filtered_ctable = ctable.filtered(args);
        stringstream ss;
        ostreamCTable(ss, filtered_ctable);
        cout << "test_filterCTable result:" << endl;
        cout << ss.str();
        TS_ASSERT_EQUALS(ss.str(),
                         "troc,truc\n"
                         "{1:1},1\n"
                         "{0:1},0\n");
    }
    void test_weightCTable()
    {
        std::cout << "\n----------------------------" << std::endl;
        string target_feature("r");
        string timestamp_feature("");
        vector<string> ignore_features;
        Table tt = loadTable(tableUTest_dir + "weighted.csv",
                             target_feature, timestamp_feature,
                             ignore_features);
        CTable ctt = tt.compressed("wgt");

        cout << "weighted result:\n" << ctt << endl;
        stringstream ss;
        ss << ctt;

        TS_ASSERT_EQUALS(ss.str(),
                   "r,a,b,c,d,e\n"
                   "{1:3.5},1,1,1,1,1\n"
                   "{1:2.66},1,1,1,0,0\n"
                   "{0:2.5},0,1,1,1,1\n"
                   "{1:0.4,0:0.8},0,0,0,0,0\n");
    }

    // Set target Price, and ignore column Temperature
    void test_target_col_ignore_col()
    {
        vertex_seq o{0.4, 9.5}; // price column
        OTable ot(o, label1);
        vector<string> il{olabel};
        ITable it(vector<type_node>({id::contin_type}), il);
        it.push_back({10.1});
        it.push_back({6.5});

        testIStreamTable("happiness,price,temperature\n"
                         "10.1,0.4,244.2\n"
                         "6.5,9.5,4.2\n", it, ot, true,
                         "price", "", {"temperature"});
    }

    void test_ignore_col_complicated()
    {
        vertex_seq o{1, 0.44, 9.5}; // price column
        OTable ot(o, label1);
        vector<string> il{olabel, "truth"};
        vector<type_node> itypes({id::enum_type, id::boolean_type});
        ITable it(itypes, il);
        it.push_back(vertex_seq({enum_t("sad"), id::logical_false}));
        it.push_back(vertex_seq({enum_t("bored"), id::logical_true}));
        it.push_back(vertex_seq({enum_t("super-happy"), id::logical_false}));
        testIStreamTable("happiness,price,temperature,truth\n"
                         "sad,1,1,0\n"
                         "bored,0.44,244.2,T\n"
                         "super-happy,9.5,4.2,F\n", it, ot, true,
                         "price", "", {"temperature"});
    }

    // // This is no longer supported
    // void test_ignore_col_numeric()
    // {
    //     vertex_seq o{1, 0.44, 9.5}; // price column
    //     OTable ot(o, label1);
    //     vector<type_node> itypes({id::enum_type, id::boolean_type});
    //     vector<string> il{olabel, "truth"};
    //     ITable it(itypes, il);
    //     it.push_back(vertex_seq({enum_t("sad"), id::logical_false}));
    //     it.push_back(vertex_seq({enum_t("bored"), id::logical_true}));
    //     it.push_back(vertex_seq({enum_t("super-happy"), id::logical_false}));
    //     testIStreamTable("happiness,price,temperature,truth\n"
    //                      "sad,1,1,0\n"
    //                      "bored,0.44,244.2,T\n"
    //                      "super-happy,9.5,4.2,F\n", it, ot, true,
    //                      // numeric values for these columns; the left-most is column 1
    //                      // so price is column 2...
    //                      // "price", {"temperature"});
    //                      "2", "", {"3"});
    // }

    void test_sparseFile1()
    {
        std::cout << "\n----------------------------" << std::endl;
        string target_feature = "target1";
        string timestamp_feature = "";
        vector<string> ignore_features = {"a", "b", "c", "target2"};
        Table tt = loadTable(tableUTest_dir + "sparse.data",
                             target_feature, timestamp_feature,
                             ignore_features);

        testIStreamTable("target1,date,d,e,f,g,x,y,z\n"
                         "thing,12-04-2012,0.0,0.0,0.0,0.0,0.0,0.0,0.0\n"
                         "some,12-05-2012,4.0,0.0,6.0,0.0,0.0,0.0,0.0\n"
                         "other,12-06-2012T14:35:02-0500,0.0,5.0,0.0,7.0,0.0,0.0,0.0\n"
                         "last,12-07-2012T16:00:00-0500,4.0,5.0,0.0,0.0,24.0,25.0,26.0\n",
                         tt.itable, tt.otable, true);
    }

    void test_sparseFile2()
    {
        std::cout << "\n----------------------------" << std::endl;
        string target_feature = "target2";
        string timestamp_feature = "";
        vector<string> ignore_features = {"a", "b", "c", "target1"};
        Table tt = loadTable(tableUTest_dir + "sparse.data",
                             target_feature, timestamp_feature,
                             ignore_features);

        testIStreamTable("target2,date,d,e,f,g,x,y,z\n"
                         "3.0,12-04-2012,0.0,0.0,0.0,0.0,0.0,0.0,0.0\n"
                         "4.4,12-05-2012,4.0,0.0,6.0,0.0,0.0,0.0,0.0\n"
                         "5.5,12-06-2012T14:35:02-0500,0.0,5.0,0.0,7.0,0.0,0.0,0.0\n"
                         "6.6,12-07-2012T16:00:00-0500,4.0,5.0,0.0,0.0,24.0,25.0,26.0\n",
                         tt.itable, tt.otable, true);
    }

    void test_mutualInformation()
    {
        std::cout << "\n----------------------------" << std::endl;
        string target_feature;
        string timestamps_feature;
        vector<string> ignore_features;
        Table tt = loadTable(tableUTest_dir + "dataset.csv",
                             target_feature, timestamps_feature,
                             ignore_features);
        set<arity_t> fs{0, 1};
        CTable ctt = tt.compressed();
        double mi = mutualInformation(ctt, fs);
        cout << "mi = " << mi << endl;
        TS_ASSERT_DELTA(0.419973, mi, 0.0001);
    }

    void test_mutualInformationBtwSets()
    {
        std::cout << "\n----------------------------" << std::endl;
        string target_feature;
        vector<string> ignore_features;
        Table tt = loadTable(tableUTest_dir + "dataset.csv");

        std::cout << "tt = " << tt << std::endl;
        set<arity_t> fs1{0};
        set<arity_t> fs2{1};
        CTable ctt = tt.compressed();
        double mi = mutualInformationBtwSets(ctt, fs1, fs2);
        cout << "mi = " << mi << endl;
        TS_ASSERT_DELTA(0.3219, mi, 0.0001);
    }

    void test_insert_get_pos()
    {
        std::cout << "\n----------------------------" << std::endl;
        ITable it;
        vertex_seq col1 = {id::logical_true, id::logical_false};
        it.insert_col("label1", col1);
        {
            stringstream ss_res;
            ss_res << it;
            TS_ASSERT_EQUALS(ss_res.str(), string("label1\nboolean\n1\n0\n"));
        }
        vertex_seq col2 = {id::logical_false, id::logical_true};
        it.insert_col("label2", col2);
        {
            stringstream ss_res;
            ss_res << it;
            TS_ASSERT_EQUALS(ss_res.str(), string("label1,label2\nboolean,boolean\n1,0\n0,1\n"));
        }
        auto lc = it.get_column_data("label2");
        it.insert_col("label3", lc, 0);
        {
            stringstream ss_res;
            ss_res << it;
            TS_ASSERT_EQUALS(ss_res.str(), string("label3,label1,label2\nboolean,boolean,boolean\n0,1,0\n1,0,1\n"));
        }
    }

    void test_force_feature()
    {
        string target_feature = "target";
        string timestamps_feature = "";
        vector<string> ignore_features = {"time", "f1"};
        string input_file = tableUTest_dir + "dataset_force_feature.csv";
        Table tt = loadTable(input_file, target_feature, timestamps_feature,
                             ignore_features);

        ostreamTable(cout << "before" << endl, tt);
        
        vector<string> features = {"time"};
        tt.add_features_from_file(input_file, features);

        ostreamTable(cout << "after" << endl, tt);

        stringstream ss;
        ostreamTable(ss, tt);
        TS_ASSERT_EQUALS(ss.str(), string("time,target,f2\n12-04-2012,1,0\n"));
    }

    void test_loadCTable()
    {
        string input_file = tableUTest_dir + "dataset.ctable";
        CTable ct = loadCTable(input_file);

        stringstream ss;
        ss << ct;

        TS_ASSERT_EQUALS(ss.str(), string("target,f1,f2\n"
                                          "{1:10,0:3},1,0\n"
                                          "{1:4,0:5},0,1\n"));
    }

    void test_timestamp_feature()
    {
        string input_file = tableUTest_dir + "timestamp_table.csv";
        Table table = loadTable(input_file, "length", "time");

        std::vector<std::string> dates_str = {"2012-Jan-11",
                                              "2012-Jan-13",
                                              "2012-Feb-18"};
        std::vector<TTable::value_type> dates;
        for (const auto& ds : dates_str)
            dates.push_back(TTable::from_string(ds));
        TTable expected_ttable(dates, "time");

#ifdef THIS_DOES_NOT_COMPILE_FOR_ME
/usr/local/include/cxxtest/TestSuite.h:56:9: error: call of overloaded
‘equals(opencog::combo::TTable&, std::vector<boost::gregorian::date>&)’
is ambiguous
/usr/local/include/cxxtest/TestSuite.h:56:9: note: candidates are:
/usr/local/include/cxxtest/TestSuite.h:45:10: note: bool
CxxTest::equals(X, Y) [with X = opencog::combo::TTable, Y =
std::vector<boost::gregorian::date>]
/usr/include/boost/algorithm/string/predicate.hpp:318:21: note: bool
boost::algorithm::equals(const Range1T&, const Range2T&) [with Range1T =
opencog::combo::TTable, Range2T = std::vector<boost::gregorian::date>]
        TS_ASSERT_EQUALS(table.ttable, dates);
#endif
    }
};
