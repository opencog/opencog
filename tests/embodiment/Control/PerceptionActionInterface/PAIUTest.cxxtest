/*
 * tests/embodiment/Control/PerceptionActionInterface/PAIUTest.cxxtest
 *
 * Copyright (C) 2002-2009 Novamente LLC
 * All Rights Reserved
 * Author(s): Welter Luigi
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/server/CogServer.h>

#include <opencog/embodiment/Control/PerceptionActionInterface/PAI.h>
#include <opencog/embodiment/Control/PerceptionActionInterface/EventResponder.h>
#include <opencog/embodiment/Control/PerceptionActionInterface/EventDetector.h>
#include "AvatarInterfaceMock.h"
#include <opencog/embodiment/AtomSpaceExtensions/AtomSpaceUtil.h>
#include "ActionPlanSenderMock.h"
#include <opencog/embodiment/AtomSpaceExtensions/PredefinedProcedureNames.h>

#include <opencog/util/exceptions.h>
#include <opencog/util/files.h>
#include <opencog/util/StringManipulator.h>

#include "PAITestUtil.h"
#include <opencog/embodiment/Control/EmbodimentConfig.h>
#include <opencog/embodiment/Control/PerceptionActionInterface/PVPXmlConstants.h>
#include <opencog/atomspace/Atom.h>
#include <opencog/atomspace/ClassServer.h>
#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/atomspace/TruthValue.h>

#include <opencog/guile/load-file.h>

using namespace opencog;
using namespace opencog::pai;
using namespace opencog::control;

std::list<ActionPlan> sentActionPlans;

class PAIUTest :  public CxxTest::TestSuite
{

private:
    AtomSpace * atomSpace;

public:
    PAIUTest() {
	config().set("ENABLE_ACTION_COLLECT", "false"); 
    }

    ~PAIUTest() {
    }

    void setUp() {
        CogServer& cogserver = static_cast<CogServer&>(server()); 
        atomSpace = cogserver.getAtomSpace();

        std::vector<Handle> outgoing_list; 
        std::vector<Handle> empty_outgoing_list; 

        Handle h_concept_node = atomSpace->addNode(CONCEPT_NODE, "plan_selected_demand_goal"); 

        outgoing_list.clear(); 
        outgoing_list.push_back( atomSpace->addNode(PREDICATE_NODE, "EnergyDemandGoal") ); 
        outgoing_list.push_back( atomSpace->addLink(LIST_LINK, empty_outgoing_list) ); 
        Handle h_demand_evaluation_link = atomSpace->addLink(EVALUATION_LINK, outgoing_list); 

        outgoing_list.clear(); 
        outgoing_list.push_back(h_concept_node); 
        outgoing_list.push_back(h_demand_evaluation_link); 
        Handle h_demand_reference_link = atomSpace->addLink(REFERENCE_LINK, outgoing_list); 
        std::cout<<atomSpace->atomAsString(h_demand_reference_link); 
    }

    void tearDown() {
        sentActionPlans.clear();
    }

    void testConstructor() {
        config(opencog::control::EmbodimentConfig::embodimentCreateInstance, true);
	config().set("ENABLE_ACTION_COLLECT", "false"); 

        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai1(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai1);
        ActionPlanID planId = pai1.createActionPlan();
        TS_ASSERT(planId == "0");
        PAI pai2(*atomSpace, sender, avatarInterface, 10);
        avatarInterface.setPAI(&pai2);
        planId = pai2.createActionPlan();
        TS_ASSERT(planId == "10");
    }

#define NUM_PLANS 100
    void testCreateActionPlan() {
        config(EmbodimentConfig::embodimentCreateInstance, true);

	config().set("ENABLE_ACTION_COLLECT", "false"); 
        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }


        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai);
        ActionPlanID plans[NUM_PLANS];
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai.createActionPlan();
        }
        for (int i = 0; i < NUM_PLANS; i++) {
            for (int j = 0; j < NUM_PLANS; j++) {
                if (i != j) {
                    TS_ASSERT(plans[i] != plans[j]);
                }
            }
        }
    }

    void testSendActionPlan() {
        config(EmbodimentConfig::embodimentCreateInstance, true);

	config().set("ENABLE_ACTION_COLLECT", "false"); 
        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai);

        TS_ASSERT_THROWS(pai.sendActionPlan("0"), RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("1"), RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("10"), RuntimeException&);

        ActionPlanID plans[NUM_PLANS];
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai.createActionPlan();
        }
        for (unsigned int i = 0; i < NUM_PLANS; i++) {
            pai.sendActionPlan(plans[i]);
            // check if it called the sendActionPlan method of the ActionPlanSender
            TS_ASSERT(sentActionPlans.size() == i + 1);
        }

        FailureActionPlanSender sender2;
        PAI pai2(*atomSpace, sender2, avatarInterface);

        TS_ASSERT_THROWS(pai2.sendActionPlan("0"), RuntimeException&);
        TS_ASSERT_THROWS(pai2.sendActionPlan("1"), RuntimeException&);
        TS_ASSERT_THROWS(pai2.sendActionPlan("10"), RuntimeException&);
        for (int i = 0; i < NUM_PLANS; i++) {
            plans[i] = pai2.createActionPlan();
        }
        for (int i = 0; i < NUM_PLANS; i++) {
            TS_ASSERT_THROWS(pai2.sendActionPlan(plans[i]), RuntimeException&);
        }
    }

    void testAddAction() {
        printf("testAddAction\n");
        config(EmbodimentConfig::embodimentCreateInstance, true);

	config().set("ENABLE_ACTION_COLLECT", "false"); 
        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai);
        ActionPlanID plan1 = pai.createActionPlan();
        ActionPlanID plan2 = pai.createActionPlan();
        pai.addAction(plan1, AvatarAction(ActionType::TRICK_FOR_FOOD()));
        TS_ASSERT_THROWS(pai.addAction(plan1, AvatarAction(ActionType::WALK())), InvalidParamException&); // invalid parameters
        pai.sendActionPlan(plan1);
        TS_ASSERT(sentActionPlans.size() == 1);
        TS_ASSERT(sentActionPlans.front().getAction(1).getType() == ActionType::TRICK_FOR_FOOD());
        AvatarAction walkAction(ActionType::WALK());
        walkAction.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(1.2, 1.3, 1.4)));
        walkAction.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), "10.5"));
        walkAction.addParameter(ActionParameter("rotate", ActionParamType::ROTATION(), Rotation(1.2, 1.3, 1.4)));
        pai.addAction(plan2, walkAction);
        pai.addAction(plan2, AvatarAction(ActionType::STEP_FORWARD()));
        AvatarAction eatAction(ActionType::EAT());
        eatAction.addParameter(ActionParameter("object", ActionParamType::ENTITY(), opencog::pai::Entity(PAIUtils::getInternalId("10"), "pet")));
        pai.addAction(plan2, eatAction);
        AvatarAction flyAction(ActionType::FLY());
        flyAction.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(1.2, 1.3, 1.4)));
        flyAction.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), "10.5"));
        pai.addAction(plan2, flyAction);
        TS_ASSERT_THROWS(pai.addAction(plan2, AvatarAction(ActionType::JUMP_TOWARD())), InvalidParamException&); // invalid parameters
        pai.sendActionPlan(plan2);
        TS_ASSERT(sentActionPlans.size() == 2);
        TS_ASSERT(sentActionPlans.back().getAction(1).getType() == ActionType::WALK());
        TS_ASSERT(sentActionPlans.back().getAction(2).getType() == ActionType::STEP_FORWARD());
        TS_ASSERT(sentActionPlans.back().getAction(3).getType() == ActionType::EAT());
        TS_ASSERT(sentActionPlans.back().getAction(4).getType() == ActionType::FLY());
    }

    void testProcessPVPMessage() {
        printf("testProcessPVPMessage\n");
        HandleSeq toUpdateHandles;
        config(EmbodimentConfig::embodimentCreateInstance, true);
	config().set("ENABLE_ACTION_COLLECT", "false"); 

        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface, 10);
        avatarInterface.setPAI(&pai);
        new EventResponder(pai , *atomSpace);
	new EventDetector(pai , *atomSpace);
        // Check Action Plan status before creating them, according with the passed "nextActionPlanId" argument to the constructor
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(!pai.hasPlanFailed("10"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));

        // Send an action-plan to get/process the corresponding avatar-signal later
        ActionPlanID planId = pai.createActionPlan();
        TS_ASSERT(planId == "10");

        AvatarAction action1(ActionType::STEP_FORWARD());
        action1.addParameter(ActionParameter("target", ActionParamType::ENTITY(), opencog::pai::Entity(PAIUtils::getInternalId("Wynx"), "avatar")));
        action1.addParameter(ActionParameter("duration", ActionParamType::FLOAT(), "1.0"));
        ActionID actionId1 = pai.addAction(planId, action1);

        AvatarAction action2(ActionType::WALK());
        action2.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(10.0, 15.0, 20.0)));
        action2.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), toString(1.0)));
        action2.addParameter(ActionParameter("frameOfReference", ActionParamType::ROTATION(), Rotation(0.5, 0.0, -3.0)));
        ActionID actionId2 = pai.addAction(planId, action2);

        pai.sendActionPlan(planId);

        planId = pai.createActionPlan();
        TS_ASSERT(planId == "11");

        AvatarAction action3(ActionType::STEP_FORWARD());
        ActionID actionId3 = pai.addAction(planId, action3);

        pai.sendActionPlan(planId);

        planId = pai.createActionPlan();
        TS_ASSERT(planId == "12");

        AvatarAction action4(ActionType::GRAB());
        action4.addParameter(ActionParameter("target", ActionParamType::ENTITY(), opencog::pai::Entity(PAIUtils::getInternalId("Wynx"), "avatar")));
        ActionID actionId4 = pai.addAction(planId, action4);

        pai.sendActionPlan(planId);

        planId = pai.createActionPlan();
        TS_ASSERT(planId == "13");

        AvatarAction action5(ActionType::DROP());
        ActionID actionId5 = pai.addAction(planId, action5);

        pai.sendActionPlan(planId);

        // GETS THE TIME THE ACTIONS WERE SENT FOR FURTHER USE:
        unsigned long justBeforeActionStatusTimestamp = PAI::getTimestampFromXsdDateTimeStr( ( boost::posix_time::to_iso_extended_string( PAIUtils::getSystemEpoch( ) ) + ".900" ).c_str( ) );
        cout << "justBeforeActionStatusTimestamp = " << justBeforeActionStatusTimestamp << endl;

        // Check Action Plan status before receiveing any message from PVP
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(!pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));
        TS_ASSERT(!pai.isPlanFinished("11"));
        TS_ASSERT(!pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        TS_ASSERT(pai.getLatestSimWorldTimestamp() == 0);

        // process first message
        string pvpMsg1;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg1.xml", pvpMsg1));
        cout << "processing first pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg1.xml" << ")" << endl << pvpMsg1 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg1, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:01.000-07:00"));

        // Check instruction atoms in AtomSpace
        {
            cout << "checking instructions" << endl;
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));
            Handle saySchemaNode = atomSpace->getHandle(GROUNDED_SCHEMA_NODE, SAY_SCHEMA_NAME);
            TS_ASSERT(Handle::compare(saySchemaNode, Handle::UNDEFINED));
            Handle avatarNode = atomSpace->getHandle(AVATAR_NODE, PAIUtils::getInternalId("2"));
            TS_ASSERT(Handle::compare(avatarNode, Handle::UNDEFINED));

            const char* sentences[6] = { "Learn to fetch", "I fetch", "done fetch",
                                         "stop learning to fetch", "Good boy!!", "Bad boy!!"
                                       };
            for (int i = 0; i < 6; i++) {
                string sentenceName("to:");
                sentenceName += PAIUtils::getInternalId("1");
                sentenceName += (": ");
                sentenceName += sentences[i];
                Handle sentenceNode = atomSpace->getHandle(SENTENCE_NODE, sentenceName);
                cout << sentences[i] << endl;
                TS_ASSERT(Handle::compare(sentenceNode, Handle::UNDEFINED));

                HandleSeq schemaListLinkOutgoing;
                schemaListLinkOutgoing.push_back(avatarNode);
                schemaListLinkOutgoing.push_back(sentenceNode);
                Handle schemaListLink = atomSpace->getHandle(LIST_LINK, schemaListLinkOutgoing);
                TS_ASSERT(Handle::compare(schemaListLink, Handle::UNDEFINED));

                HandleSeq execLinkOutgoing;
                execLinkOutgoing.push_back(saySchemaNode);
                execLinkOutgoing.push_back(schemaListLink);
                Handle execLink = atomSpace->getHandle(EXECUTION_LINK, execLinkOutgoing);
                TS_ASSERT(Handle::compare(execLink, Handle::UNDEFINED));

                HandleSeq predicateListLinkOutgoing;
                predicateListLinkOutgoing.push_back(execLink);
                Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));


                HandleSeq evalLinkOutgoing;
                evalLinkOutgoing.push_back(predNode);
                evalLinkOutgoing.push_back(predicateListLink);
                Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
            }
        }

        // Check Pet-signal atoms

        // Check Physiological feeling in AtomSpace
        {
            cout << "checking pet signals: physiological feelings " << endl;
            string id = PAIUtils::getInternalId("1");
            string pred = "hunger";
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, pred.c_str());
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));
            cout << atomSpace->atomAsString(predNode) << endl;

            Handle eval = atomSpace->getIncoming(predNode)[0];
            cout << atomSpace->cloneAtom(eval)->toString() << endl;
            TS_ASSERT_EQUALS(atomSpace->getIncoming(predNode).size(), 1);

            Handle atTime = atomSpace->getIncoming(eval)[0];
            cout << atomSpace->cloneAtom(atTime)->toString() << endl;
            TS_ASSERT_EQUALS(atomSpace->getIncoming(atTime).size(), 1);

            TS_ASSERT_DELTA(atomSpace->getTV(atTime)->getMean(), 0.9, 0.0001);

            // @todo check the ListLink and pet node
        }

        // Check Action Plan status
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(!pai.isPlanFinished("10"));
        TS_ASSERT(!pai.isPlanFinished("11"));
        TS_ASSERT(!pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        // Check Action status in AtomSpace
        {
            // FIRST, USING PAI SPECIAL METHODS:
            TS_ASSERT(!pai.isActionDone(actionId1, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionDone(actionId2, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionDone(actionId3, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionDone(actionId4, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionDone(actionId5, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionFailed(actionId1, justBeforeActionStatusTimestamp));
            TS_ASSERT(pai.isActionFailed(actionId2, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionFailed(actionId3, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionFailed(actionId4, justBeforeActionStatusTimestamp));
            TS_ASSERT(!pai.isActionFailed(actionId5, justBeforeActionStatusTimestamp));

            // THEN, USING THE HARD WAY

            cout << "checking pet signals: action status " << endl;
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_FAILED_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace->getHandle(GROUNDED_SCHEMA_NODE, ActionType::WALK().getName());
            TS_ASSERT(Handle::compare(schemaNode, Handle::UNDEFINED));

            /*
            HandleSeq numberNodes;
            atomSpace->getHandleSet(back_inserter(numberNodes), NUMBER_NODE, false);
            cout << "Got " << numberNodes.size() << " NumberNodes:" << endl;
            for (int i = 0; i < numberNodes.size(); i++) {
                cout << TLB::getAtom(numberNodes[i])->toString() << endl;
            }
            */

            // Action parameters
            HandleSeq schemaListLinkOutgoing;

            // Vector target: action2.addParameter(ActionParameter("target", ActionParamType::VECTOR(), Vector(10.0,15.0,20.0)));
            Handle xNode = atomSpace->getHandle(NUMBER_NODE, "10");
            TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace->getHandle(NUMBER_NODE, "15");
            TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace->getHandle(NUMBER_NODE, "20");
            TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode);
            targetListLinkOutgoing.push_back(yNode);
            targetListLinkOutgoing.push_back(zNode);
            Handle targetListLink = atomSpace->getHandle(LIST_LINK, targetListLinkOutgoing);
            schemaListLinkOutgoing.push_back(targetListLink);

            // Float speed: action2.addParameter(ActionParameter("speed", ActionParamType::FLOAT(), toString(1.0)));
            Handle speedNode = atomSpace->getHandle(NUMBER_NODE, "1");
            TS_ASSERT(Handle::compare(speedNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(speedNode);

            // Rotation rotate: action2.addParameter(ActionParameter("rotate", ActionParamType::ROTATION(), Rotation(0.5,0.0,-3.0)));
            Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "0.5");
            TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "0");
            TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "-3");
            TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode);
            rotateListLinkOutgoing.push_back(rollNode);
            rotateListLinkOutgoing.push_back(yawNode);
            Handle rotateListLink = atomSpace->getHandle(LIST_LINK, rotateListLinkOutgoing);
            schemaListLinkOutgoing.push_back(rotateListLink);

            Handle schemaListLink = atomSpace->getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(Handle::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace->getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(Handle::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
        }

        // process next message
        string pvpMsg2;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg2.xml", pvpMsg2));
        cout << "processing second pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg2.xml" << ")" << endl << pvpMsg2 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg2, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:02.000-07:00"));

        // Check Action Plan status
        TS_ASSERT(!pai.hasPlanFailed("0"));
        TS_ASSERT(!pai.hasPlanFailed("9"));
        TS_ASSERT(pai.hasPlanFailed("10"));
        TS_ASSERT(!pai.hasPlanFailed("11"));
        TS_ASSERT(!pai.hasPlanFailed("12"));
        TS_ASSERT(!pai.hasPlanFailed("13"));
        TS_ASSERT(pai.isPlanFinished("0"));
        TS_ASSERT(pai.isPlanFinished("9"));
        TS_ASSERT(pai.isPlanFinished("10"));
        TS_ASSERT(pai.isPlanFinished("11"));
        TS_ASSERT(pai.isPlanFinished("12"));
        TS_ASSERT(!pai.isPlanFinished("13"));

        // Check Action status in AtomSpace

        // CHECK ACTION STATUS USING PAI SPECIAL METHODS:
        TS_ASSERT(pai.isActionDone(actionId1, justBeforeActionStatusTimestamp));
        TS_ASSERT(!pai.isActionDone(actionId2, justBeforeActionStatusTimestamp));
        TS_ASSERT(pai.isActionDone(actionId3, justBeforeActionStatusTimestamp));
        TS_ASSERT(!pai.isActionFailed(actionId1, justBeforeActionStatusTimestamp));
        TS_ASSERT(pai.isActionFailed(actionId2, justBeforeActionStatusTimestamp));
        TS_ASSERT(!pai.isActionFailed(actionId3, justBeforeActionStatusTimestamp));

        // Get the status for the first action
        {
            cout << "checking pet signals: action status" << endl;
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace->getHandle(GROUNDED_SCHEMA_NODE, ActionType::STEP_FORWARD().getName());
            TS_ASSERT(Handle::compare(schemaNode, Handle::UNDEFINED));

            HandleSeq schemaListLinkOutgoing;

            //Action parameters:
            //action1.addParameter(ActionParameter("duration", ActionParamType::FLOAT(), "1.0"));
            //action1.addParameter(ActionParameter("target", ActionParamType::ENTITY(), opencog::pai::Entity(PAIUtils::getInternalId("Wynx"), "avatar")));
            Handle avatarNode = atomSpace->getHandle(AVATAR_NODE, PAIUtils::getInternalId("Wynx").c_str());
            TS_ASSERT(Handle::compare(avatarNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(avatarNode);
            Handle numberNode = atomSpace->getHandle(NUMBER_NODE, "1.0");
            TS_ASSERT(Handle::compare(numberNode, Handle::UNDEFINED));
            schemaListLinkOutgoing.push_back(numberNode);

            Handle schemaListLink = atomSpace->getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(Handle::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace->getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(Handle::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
        }

        // Get the status for the third action
        {
            cout << "checking pet signals: action status" << endl;
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));
            Handle schemaNode = atomSpace->getHandle(GROUNDED_SCHEMA_NODE, ActionType::STEP_FORWARD().getName());
            TS_ASSERT(Handle::compare(schemaNode, Handle::UNDEFINED));

            HandleSeq schemaListLinkOutgoing;
            Handle schemaListLink = atomSpace->getHandle(LIST_LINK, schemaListLinkOutgoing);
            TS_ASSERT(Handle::compare(schemaListLink, Handle::UNDEFINED));

            HandleSeq execLinkOutgoing;
            execLinkOutgoing.push_back(schemaNode);
            execLinkOutgoing.push_back(schemaListLink);
            Handle execLink = atomSpace->getHandle(EXECUTION_LINK, execLinkOutgoing);
            TS_ASSERT(Handle::compare(execLink, Handle::UNDEFINED));

            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(execLink);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(predNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
        }

        // Check grab status in AvatarInterface
        {
            TS_ASSERT(!pai.hasPlanFailed("12"));
            TS_ASSERT(!pai.hasPlanFailed("13"));
            TS_ASSERT(pai.isPlanFinished("12"));
            TS_ASSERT(!pai.isPlanFinished("13"));

            TS_ASSERT(pai.getAvatarInterface().hasGrabbedObj());
            TS_ASSERT(pai.getAvatarInterface().getGrabbedObj() == PAIUtils::getInternalId("Wynx"));
        }

        // Check agent-signal atoms
        {
            cout << "checking agent signals" << endl;

	    // Avatar node
            Handle avatarNode = atomSpace->getHandle(AVATAR_NODE, PAIUtils::getInternalId("1").c_str());
            TS_ASSERT(Handle::compare(avatarNode, Handle::UNDEFINED));
     

            // Action node
            Handle actionNode = atomSpace->getHandle(CONCEPT_NODE, "walk");
            TS_ASSERT(Handle::compare(actionNode, Handle::UNDEFINED));
      
            // speed concept node
            Handle speedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "speed");
            TS_ASSERT(Handle::compare(speedConceptNode, Handle::UNDEFINED));

            // walk:speed concept node
            Handle walkSpeedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "walk:speed");
            TS_ASSERT(Handle::compare(walkSpeedConceptNode, Handle::UNDEFINED));

            // ActionInstance node
            Handle actionInstanceNode = atomSpace->getHandle(CONCEPT_NODE, "walk24");
            TS_ASSERT(Handle::compare(actionInstanceNode, Handle::UNDEFINED));

            // Vector <vector x=\"1\" y=\"1.5\" z=\"2\"/>"
            Handle xNode = atomSpace->getHandle(NUMBER_NODE, "1");
            TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace->getHandle(NUMBER_NODE, "1.5");
            TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace->getHandle(NUMBER_NODE, "2");
            TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode);
            targetListLinkOutgoing.push_back(yNode);
            targetListLinkOutgoing.push_back(zNode);
            Handle targetListLink = atomSpace->getHandle(LIST_LINK, targetListLinkOutgoing);

            // Speed <param name=\"speed\" type=\"float\" value=\"3.5\"/>"
            Handle speedNode = atomSpace->getHandle(NUMBER_NODE, "3.5");
            TS_ASSERT(Handle::compare(speedNode, Handle::UNDEFINED));
         
            // Rotation <rotation pitch=\"0.1\" roll=\"0.2\" yaw=\"0.3\"/>"
            Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "0.1");
            TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "0.2");
            TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "0.3");
            TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode);
            rotateListLinkOutgoing.push_back(rollNode);
            rotateListLinkOutgoing.push_back(yawNode);
            Handle rotateListLink = atomSpace->getHandle(LIST_LINK, rotateListLinkOutgoing);

            // Result state
            Handle actionResultPrediceteNode = atomSpace->getHandle(PREDICATE_NODE, "walk:result-state");
            TS_ASSERT(Handle::compare(actionResultPrediceteNode, Handle::UNDEFINED));

            Handle resultNode = atomSpace->getHandle(CONCEPT_NODE, ACTION_DONE_PREDICATE_NAME );
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(actionInstanceNode);
            predicateListLinkOutgoing.push_back(resultNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
	    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

	    HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(actionResultPrediceteNode);
	    evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
        }

        // Check Avatar-signal atoms (pet)
        {
            cout << "checking avatar signals" << endl;

            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));


            // Agent node
            Handle agentNode = atomSpace->getHandle(PET_NODE, PAIUtils::getInternalId("3").c_str());
            TS_ASSERT(Handle::compare(agentNode, Handle::UNDEFINED));


            // Action node
            Handle actionNode = atomSpace->getHandle(CONCEPT_NODE, "walk");
            TS_ASSERT(Handle::compare(actionNode, Handle::UNDEFINED));
      
            // speed concept node
            Handle speedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "speed");
            TS_ASSERT(Handle::compare(speedConceptNode, Handle::UNDEFINED));

            // walk:speed concept node
            Handle walkSpeedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "walk:speed");
            TS_ASSERT(Handle::compare(walkSpeedConceptNode, Handle::UNDEFINED));

            // ActionInstance node
            Handle actionInstanceNode = atomSpace->getHandle(CONCEPT_NODE, "walk85");
            TS_ASSERT(Handle::compare(actionInstanceNode, Handle::UNDEFINED));

            // Vector <vector x=\"1\" y=\"1.5\" z=\"2\"/>"
            Handle xNode = atomSpace->getHandle(NUMBER_NODE, "3");
            TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace->getHandle(NUMBER_NODE, "5.5");
            TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace->getHandle(NUMBER_NODE, "2.9");
            TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode);
            targetListLinkOutgoing.push_back(yNode);
            targetListLinkOutgoing.push_back(zNode);
            Handle targetListLink = atomSpace->getHandle(LIST_LINK, targetListLinkOutgoing);

            // Speed <param name=\"speed\" type=\"float\" value=\"3.5\"/>"
            Handle speedNode = atomSpace->getHandle(NUMBER_NODE, "3.87");
            TS_ASSERT(Handle::compare(speedNode, Handle::UNDEFINED));
         
            // Rotation <rotation pitch=\"0.1\" roll=\"0.2\" yaw=\"0.3\"/>"
            Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "0.111");
            TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "0.221");
            TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "0.341");
            TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode);
            rotateListLinkOutgoing.push_back(rollNode);
            rotateListLinkOutgoing.push_back(yawNode);
            Handle rotateListLink = atomSpace->getHandle(LIST_LINK, rotateListLinkOutgoing);

            // Result state
            Handle actionResultPrediceteNode = atomSpace->getHandle(PREDICATE_NODE, "walk:result-state");
            TS_ASSERT(Handle::compare(actionResultPrediceteNode, Handle::UNDEFINED));

            Handle resultNode = atomSpace->getHandle(CONCEPT_NODE, ACTION_DONE_PREDICATE_NAME );
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(actionInstanceNode);
            predicateListLinkOutgoing.push_back(resultNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(actionResultPrediceteNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

        }

        // Check Avatar-signal atoms (avatar)
        {
            cout << "checking avatar signals" << endl;
            Handle predNode = atomSpace->getHandle(PREDICATE_NODE, ACTION_DONE_PREDICATE_NAME);
            TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));


            // Agent node
            Handle agentNode = atomSpace->getHandle(AVATAR_NODE, PAIUtils::getInternalId("9").c_str());
            TS_ASSERT(Handle::compare(agentNode, Handle::UNDEFINED));

            // Action node
            Handle actionNode = atomSpace->getHandle(CONCEPT_NODE, "walk");
            TS_ASSERT(Handle::compare(actionNode, Handle::UNDEFINED));
      
            // speed concept node
            Handle speedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "speed");
            TS_ASSERT(Handle::compare(speedConceptNode, Handle::UNDEFINED));

            // walk:speed concept node
            Handle walkSpeedConceptNode = atomSpace->getHandle(PREDICATE_NODE, "walk:speed");
            TS_ASSERT(Handle::compare(walkSpeedConceptNode, Handle::UNDEFINED));

            // ActionInstance node
            Handle actionInstanceNode = atomSpace->getHandle(CONCEPT_NODE, "walk93");
            TS_ASSERT(Handle::compare(actionInstanceNode, Handle::UNDEFINED));

            // Vector <vector x=\"1\" y=\"1.5\" z=\"2\"/>"
            Handle xNode = atomSpace->getHandle(NUMBER_NODE, "1.01");
            TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
            Handle yNode = atomSpace->getHandle(NUMBER_NODE, "1.77");
            TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
            Handle zNode = atomSpace->getHandle(NUMBER_NODE, "2.1");
            TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));
            HandleSeq targetListLinkOutgoing;
            targetListLinkOutgoing.push_back(xNode);
            targetListLinkOutgoing.push_back(yNode);
            targetListLinkOutgoing.push_back(zNode);
            Handle targetListLink = atomSpace->getHandle(LIST_LINK, targetListLinkOutgoing);

            // Speed <param name=\"speed\" type=\"float\" value=\"3.5\"/>"
            Handle speedNode = atomSpace->getHandle(NUMBER_NODE, "8.5");
            TS_ASSERT(Handle::compare(speedNode, Handle::UNDEFINED));
         
            // Rotation <rotation pitch=\"0.1\" roll=\"0.2\" yaw=\"0.3\"/>"
            Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "0.3274");
            TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
            Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "0.517");
            TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
            Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "0.87");
            TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));
            HandleSeq rotateListLinkOutgoing;
            rotateListLinkOutgoing.push_back(pitchNode);
            rotateListLinkOutgoing.push_back(rollNode);
            rotateListLinkOutgoing.push_back(yawNode);
            Handle rotateListLink = atomSpace->getHandle(LIST_LINK, rotateListLinkOutgoing);

            // Result state
            Handle actionResultPrediceteNode = atomSpace->getHandle(PREDICATE_NODE, "walk:result-state");
            TS_ASSERT(Handle::compare(actionResultPrediceteNode, Handle::UNDEFINED));

            Handle resultNode = atomSpace->getHandle(CONCEPT_NODE, ACTION_DONE_PREDICATE_NAME );
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(actionInstanceNode);
            predicateListLinkOutgoing.push_back(resultNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(actionResultPrediceteNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

        }

        // Check map-info atoms
        {
            cout << "checking map info" << endl;

            // entities
            Handle wynxNode = atomSpace->getHandle(AVATAR_NODE, PAIUtils::getInternalId("2").c_str());
            TS_ASSERT(Handle::compare(wynxNode, Handle::UNDEFINED));
            Handle stickNode = atomSpace->getHandle(ACCESSORY_NODE, PAIUtils::getInternalId("Stick").c_str());
            TS_ASSERT(Handle::compare(stickNode, Handle::UNDEFINED));
            Handle whistleNode = atomSpace->getHandle(ACCESSORY_NODE, PAIUtils::getInternalId("whistle").c_str());
            TS_ASSERT(Handle::compare(whistleNode, Handle::UNDEFINED));
            Handle fidoNode = atomSpace->getHandle(PET_NODE, PAIUtils::getInternalId("1").c_str());
            TS_ASSERT(Handle::compare(fidoNode, Handle::UNDEFINED));
            Handle homeNode = atomSpace->getHandle(STRUCTURE_NODE, PAIUtils::getInternalId("house").c_str());
            TS_ASSERT(Handle::compare(homeNode, Handle::UNDEFINED));
            Handle foodBowlNode = atomSpace->getHandle(STRUCTURE_NODE, PAIUtils::getInternalId("bow").c_str());
            TS_ASSERT(Handle::compare(foodBowlNode, Handle::UNDEFINED));
            Handle waterBowlNode = atomSpace->getHandle(STRUCTURE_NODE, PAIUtils::getInternalId("Water bow").c_str());
            TS_ASSERT(Handle::compare(waterBowlNode, Handle::UNDEFINED));

            Handle woodConceptNode = atomSpace->getHandle(CONCEPT_NODE, "wood");
            Handle smoothConceptNode = atomSpace->getHandle(CONCEPT_NODE, "smooth");
            Handle brownConceptNode = atomSpace->getHandle(CONCEPT_NODE, "brown");
            Handle redConceptNode = atomSpace->getHandle(CONCEPT_NODE, "red");
            Handle blueConceptNode = atomSpace->getHandle(CONCEPT_NODE, "blue");
            Handle greenConceptNode = atomSpace->getHandle(CONCEPT_NODE, "green");
            Handle whiteConceptNode = atomSpace->getHandle(CONCEPT_NODE, "white");
            Handle blackConceptNode = atomSpace->getHandle(CONCEPT_NODE, "black");
            Handle grayConceptNode = atomSpace->getHandle(CONCEPT_NODE, "gray");

            TS_ASSERT(!AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "is_drinkable",
                      whistleNode));
            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "is_edible",
                      whistleNode));

            // check is_moving predicates
            TS_ASSERT(!AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "is_moving",
                      waterBowlNode));
            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "is_moving",
                      whistleNode));

            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "is_toy",
                      stickNode));

            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "color",
                      stickNode,
                      brownConceptNode ));


            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "texture",
                      stickNode,
                      smoothConceptNode ));

            TS_ASSERT(AtomSpaceUtil::isPredicateTrue(*atomSpace,
                      "material",
                      stickNode,
                      woodConceptNode));

            Handle colorPredNode = atomSpace->getHandle(PREDICATE_NODE, "color");
           
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(brownConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 1.0f, 0.001);
            }

            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(redConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.75f, 0.001);
            }
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(blueConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.5f, 0.001);
            }
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(greenConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.25f, 0.001);
            }
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(whiteConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.15f, 0.001);
            }
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(blackConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.1f, 0.001);
            }
            {
            HandleSeq predicateListLinkOutgoing;
            predicateListLinkOutgoing.push_back(stickNode);
            predicateListLinkOutgoing.push_back(grayConceptNode);
            Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
            TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

            HandleSeq evalLinkOutgoing;
            evalLinkOutgoing.push_back(colorPredNode);
            evalLinkOutgoing.push_back(predicateListLink);
            Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
            TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));

            TS_ASSERT_DELTA(atomSpace->getMean(evalLink), 0.05f, 0.001);
            }

            HandleSeq seq;
            seq.push_back(homeNode);
            seq.push_back(atomSpace->addNode(CONCEPT_NODE, "pet_home"));

            vector<Handle> handles;
            atomSpace->getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);
            TS_ASSERT(handles.size() == 1);

            seq.clear();
            seq.push_back(foodBowlNode);
            seq.push_back(atomSpace->addNode(CONCEPT_NODE, "food_bowl"));

            handles.clear();
            atomSpace->getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);
            //printf("Handles.size() %d\n", handles.size());
            TS_ASSERT(handles.size() == 1);

            seq.clear();
            seq.push_back(waterBowlNode);
            seq.push_back(atomSpace->addNode(CONCEPT_NODE, "water_bowl"));

            handles.clear();
            atomSpace->getHandleSet(back_inserter(handles), seq, NULL, NULL, 2,
                                   INHERITANCE_LINK, false);

            //printf("Handles.size() %d\n", handles.size());
            TS_ASSERT(handles.size() == 1);



            // entity types
            Handle avatarNode = atomSpace->getHandle(NODE, "avatar");
            TS_ASSERT(Handle::compare(avatarNode, Handle::UNDEFINED));
            Handle accessoryNode = atomSpace->getHandle(NODE, "accessory");
            TS_ASSERT(Handle::compare(accessoryNode, Handle::UNDEFINED));
            Handle petNode = atomSpace->getHandle(NODE, "pet");
            TS_ASSERT(Handle::compare(petNode, Handle::UNDEFINED));

            // Inheritance links
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(wynxNode);
                inhLinkOutgoing.push_back(avatarNode);
                Handle inhLink = atomSpace->getHandle(INHERITANCE_LINK, inhLinkOutgoing);
                TS_ASSERT(Handle::compare(inhLink, Handle::UNDEFINED));
            }
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(stickNode);
                inhLinkOutgoing.push_back(accessoryNode);
                Handle inhLink = atomSpace->getHandle(INHERITANCE_LINK, inhLinkOutgoing);
                TS_ASSERT(Handle::compare(inhLink, Handle::UNDEFINED));
            }
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(whistleNode);
                inhLinkOutgoing.push_back(accessoryNode);
                Handle inhLink = atomSpace->getHandle(INHERITANCE_LINK, inhLinkOutgoing);
                TS_ASSERT(Handle::compare(inhLink, Handle::UNDEFINED));
            }
            {
                HandleSeq inhLinkOutgoing;
                inhLinkOutgoing.push_back(fidoNode);
                inhLinkOutgoing.push_back(petNode);
                Handle inhLink = atomSpace->getHandle(INHERITANCE_LINK, inhLinkOutgoing);
                TS_ASSERT(Handle::compare(inhLink, Handle::UNDEFINED));
            }

            // Position predicates
            {
                Handle predNode = atomSpace->getHandle(PREDICATE_NODE, AGISIM_POSITION_PREDICATE_NAME);
                TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));

                // Wynx: <position x=\"15\" y=\"164\" z=\"14\"/>\n"
                {
                    Handle xNode = atomSpace->getHandle(NUMBER_NODE, "15");
                    TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace->getHandle(NUMBER_NODE, "164");
                    TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace->getHandle(NUMBER_NODE, "14");
                    TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(wynxNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Stick: <position x=\"5.051\" y=\"64.251\" z=\"4.251\"/>\n"
                {
                    Handle xNode = atomSpace->getHandle(NUMBER_NODE, "5.051");
                    TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace->getHandle(NUMBER_NODE, "64.251");
                    TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace->getHandle(NUMBER_NODE, "4.251");
                    TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(stickNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Whistle: <position x=\"5.052\" y=\"64.252\" z=\"4.252\"/>\n"
                {
                    Handle xNode = atomSpace->getHandle(NUMBER_NODE, "5.052");
                    TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace->getHandle(NUMBER_NODE, "64.252");
                    TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace->getHandle(NUMBER_NODE, "4.252");
                    TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(whistleNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Fido: <position x=\"25\" y=\"165\" z=\"23.2\"/>\n"
                {
                    Handle xNode = atomSpace->getHandle(NUMBER_NODE, "25");
                    TS_ASSERT(Handle::compare(xNode, Handle::UNDEFINED));
                    Handle yNode = atomSpace->getHandle(NUMBER_NODE, "165");
                    TS_ASSERT(Handle::compare(yNode, Handle::UNDEFINED));
                    Handle zNode = atomSpace->getHandle(NUMBER_NODE, "23.2");
                    TS_ASSERT(Handle::compare(zNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(fidoNode);
                    predicateListLinkOutgoing.push_back(xNode);
                    predicateListLinkOutgoing.push_back(yNode);
                    predicateListLinkOutgoing.push_back(zNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

            } // positions

            // Rotation predicate
            {
                Handle predNode = atomSpace->getHandle(PREDICATE_NODE, "AGISIM_rotation");
                TS_ASSERT(Handle::compare(predNode, Handle::UNDEFINED));

                // Wynx: <rotation pitch=\"0.01\" roll=\"0.02\" yaw=\"2.53\"/>
                {
                    Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "0.01");
                    TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "0.02");
                    TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "2.53");
                    TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(wynxNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Stick: <rotation pitch=\"10\" roll=\"10\" yaw=\"12.5\"/>\n"
                {
                    Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "10");
                    TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "10");
                    TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "12.5");
                    TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(stickNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Whistle: <rotation pitch=\"20\" roll=\"20\" yaw=\"22.5\"/>\n"
                {
                    Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "20");
                    TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "20");
                    TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "22.5");
                    TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(whistleNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

                // Fido: <rotation pitch=\"30\" roll=\"30\" yaw=\"182.5\"/>\n"
                {
                    Handle pitchNode = atomSpace->getHandle(NUMBER_NODE, "30");
                    TS_ASSERT(Handle::compare(pitchNode, Handle::UNDEFINED));
                    Handle rollNode = atomSpace->getHandle(NUMBER_NODE, "30");
                    TS_ASSERT(Handle::compare(rollNode, Handle::UNDEFINED));
                    Handle yawNode = atomSpace->getHandle(NUMBER_NODE, "182.5");
                    TS_ASSERT(Handle::compare(yawNode, Handle::UNDEFINED));

                    HandleSeq predicateListLinkOutgoing;
                    predicateListLinkOutgoing.push_back(fidoNode);
                    predicateListLinkOutgoing.push_back(pitchNode);
                    predicateListLinkOutgoing.push_back(rollNode);
                    predicateListLinkOutgoing.push_back(yawNode);
                    Handle predicateListLink = atomSpace->getHandle(LIST_LINK, predicateListLinkOutgoing);
                    TS_ASSERT(Handle::compare(predicateListLink, Handle::UNDEFINED));

                    HandleSeq evalLinkOutgoing;
                    evalLinkOutgoing.push_back(predNode);
                    evalLinkOutgoing.push_back(predicateListLink);
                    Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
                    TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED));
                }

            } // rotations
        } // map-info

        // process next message
        string pvpMsg3;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg3.xml", pvpMsg3));
        cout << "processing third pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg3.xml" << ")" << endl << pvpMsg3 << endl;
        TS_ASSERT(pai.processPVPMessage(pvpMsg3, toUpdateHandles));

        // Check latest received/processed timestamp
        TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:15:04.000-07:00"));

        // Check grab status in AvatarInterface
        {
            TS_ASSERT(!pai.hasPlanFailed("12"));
            TS_ASSERT(!pai.hasPlanFailed("13"));
            TS_ASSERT(pai.isPlanFinished("12"));
            TS_ASSERT(pai.isPlanFinished("13"));

            TS_ASSERT(!pai.getAvatarInterface().hasGrabbedObj());
            TS_ASSERT(pai.getAvatarInterface().getGrabbedObj() == string(""));
        }

        // process next message
        string pvpMsg4;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/pvpMsg4.xml", pvpMsg4));
        cout << "processing forth pvp message (" << PVP_XML_FILE_PATH << "/pvpMsg4.xml" << ")" << endl << pvpMsg4 << endl;
        TS_ASSERT(! pai.processPVPMessage(pvpMsg4, toUpdateHandles));
    } // testProcessPVPMessage

    void testProcessPVPMessageWithProtobuf() {

    }

    void testTimestampRelatedMethods() {
        unsigned long t1 = PAITestUtil::getCurrentTimestamp();
        sleep(1);
        unsigned long t2 = PAITestUtil::getCurrentTimestamp();
        printf ("t1 = %lu, t2=%lu, delta = %lu\n", t1, t2, t2 - t1);
#ifdef DATETIME_DECIMAL_RESOLUTION
        TS_ASSERT(t2 >= t1 + 10);
        TS_ASSERT(t2 <= t1 + 20); // 1 more second of tolerance
#else
        // centesimal
        TS_ASSERT(t2 >= t1 + 100);
        TS_ASSERT(t2 <= t1 + 200); // 1 more second of tolerance
#endif

        config(EmbodimentConfig::embodimentCreateInstance, true);
	config().set("ENABLE_ACTION_COLLECT", "false"); 
	
        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai);

        /*
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == 0);
                TS_ASSERT(pai.setLatestSimWorldTimestamp(t1));
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == t1);
                TS_ASSERT(pai.setLatestSimWorldTimestamp(t2));
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
                TS_ASSERT(!pai.setLatestSimWorldTimestamp(t1));
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
        */

        unsigned long t3 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00.100-07:00");
        unsigned long t4 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00.200-07:00");
        unsigned long t5 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T23:00:00.200Z");
        unsigned long t6 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T15:00:00.200-08:00");
        unsigned long t7 = PAI::getTimestampFromXsdDateTimeStr("2007-06-20T01:00:00.200+02:00");
        printf ("t3 = %lu, t4=%lu, delta=%lu\n", t3, t4, t4 - t3);
        printf ("20 hours = %lu min, %lu seg, %lu decimals of seg, %lu cent of secs\n",
                (unsigned long)20*60, (unsigned long)20*60*60, (unsigned long)20*60*60*10,
                (unsigned long)20*60*60*100);
#ifdef DATETIME_DECIMAL_RESOLUTION
        printf("Decimal resolution\n");
        TS_ASSERT_EQUALS(t3 + 20*60*60*10 + 1, t4);
#else
        TS_ASSERT_EQUALS(t3 + 20*60*60*100 + 10, t4);
#endif

        // all dateTimes should be the same in UTC time
        TS_ASSERT_EQUALS(t4, t5);
        TS_ASSERT_EQUALS(t4, t6);
        TS_ASSERT_EQUALS(t4, t7);

        unsigned long t8 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00.000-07:00");
        unsigned long t9 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00.000-07:00");

        // Test specific case of detected bug (no second fraction in the timestamp string):
        for (int i = 0; i < 100; i++) {
            unsigned long t10 = PAI::getTimestampFromXsdDateTimeStr("2007-06-18T20:00:00-07:00");
            unsigned long t11 = PAI::getTimestampFromXsdDateTimeStr("2007-06-19T16:00:00-07:00");
            TS_ASSERT_EQUALS(t8, t10);
            TS_ASSERT_EQUALS(t9, t11);
        }
        /*
                TS_ASSERT(!pai.setLatestSimWorldTimestamp(t3));
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
                TS_ASSERT(!pai.setLatestSimWorldTimestamp(t4));
                TS_ASSERT(pai.getLatestSimWorldTimestamp() == t2);
        */
    }

    void testProcessPVPMessageWithScheme(){
        printf("testProcessPVPMessageWithScheme\n");
        HandleSeq toUpdateHandles;
        config(EmbodimentConfig::embodimentCreateInstance, true);
	config().set("ENABLE_ACTION_COLLECT", "false"); 

        if (fileExists(config().get("CONFIG_FILE").c_str())) {
            config().load(config().get("CONFIG_FILE").c_str());
        }

        //set the scheme typesdefs path 
        config().set("SCHEME_TYPEDEFS_PATH",PROJECT_SOURCE_DIR"/tests/scm/typedefs.scm");

        int rc = load_scm_file(*atomSpace, PROJECT_SOURCE_DIR"/tests/scm/typedefs.scm");
        TSM_ASSERT_EQUALS("Failed to load type definition utilities", 0, rc);

        OKActionPlanSender sender(sentActionPlans);
        AvatarInterfaceMock avatarInterface;
        PAI pai(*atomSpace, sender, avatarInterface);
        avatarInterface.setPAI(&pai);

        TS_ASSERT_THROWS(pai.sendActionPlan("0"), RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("1"), RuntimeException&);
        TS_ASSERT_THROWS(pai.sendActionPlan("10"), RuntimeException&);


        // process first scheme instruction message
        string schemeMsg1;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg1.xml", schemeMsg1));
        cout << "processing first scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg1.xml" << ")" << endl << schemeMsg1 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg1, toUpdateHandles));

        //TODO check it it is needed to assert the timestamp
        // Check latest received/processed timestamp
        //TS_ASSERT(pai.getLatestSimWorldTimestamp() == PAI::getTimestampFromXsdDateTimeStr("2009-05-29T18:29:57.187"));

    
        // Check instruction atoms in AtomSpace
        {
 
        cout << "checking scheme instructions" << endl;
        Handle node;

        {
        Handle wiNode = atomSpace->getHandle(WORD_INSTANCE_NODE, "go@0b75986f-7176-4f7a-8815-3f3afb0e2837");
        TS_ASSERT(Handle::compare(wiNode, Handle::UNDEFINED));

        Handle wNode = atomSpace->getHandle(WORD_NODE, "go");
        TS_ASSERT(Handle::compare(wNode, Handle::UNDEFINED));

        HandleSeq refLinkOutgoing;
        refLinkOutgoing.push_back(wiNode);
        refLinkOutgoing.push_back(wNode);
        Handle refLink = atomSpace->getHandle(REFERENCE_LINK, refLinkOutgoing);
        TS_ASSERT(Handle::compare(refLink, Handle::UNDEFINED));        

        Handle parseNode = atomSpace->getHandle(PARSE_NODE, "sentence@364a3d3d-f42f-4c5d-b3b0-73f5b824581d_parse_0");
        TS_ASSERT(Handle::compare(parseNode, Handle::UNDEFINED));
        
        HandleSeq wiLinkOutgoing;
        wiLinkOutgoing.push_back(wiNode);
        wiLinkOutgoing.push_back(parseNode);
        Handle wiLink = atomSpace->getHandle(WORD_INSTANCE_LINK, wiLinkOutgoing);
        TS_ASSERT(Handle::compare(wiLink, Handle::UNDEFINED));
        
        /*
        (LemmaLink (stv 1.0 1.0)
           (WordInstanceNode "go@0b75986f-7176-4f7a-8815-3f3afb0e2837")
           (WordNode "go")
        )
        */
        HandleSeq lemmaLinkOutgoing;
        lemmaLinkOutgoing.push_back(wiNode);
        lemmaLinkOutgoing.push_back(wNode);
        Handle lemmaLink = atomSpace->getHandle(LEMMA_LINK, lemmaLinkOutgoing);
        TS_ASSERT(Handle::compare(lemmaLink, Handle::UNDEFINED));

        }

        {
        Handle wiNode = atomSpace->getHandle(WORD_INSTANCE_NODE, "fetch@85c27c19-7980-417d-89f2-d2748395932c");
        TS_ASSERT(Handle::compare(wiNode, Handle::UNDEFINED));

        Handle wNode = atomSpace->getHandle(WORD_NODE, "fetch");
        TS_ASSERT(Handle::compare(wNode, Handle::UNDEFINED));

        HandleSeq refLinkOutgoing;
        refLinkOutgoing.push_back(wiNode);
        refLinkOutgoing.push_back(wNode);
        Handle refLink = atomSpace->getHandle(REFERENCE_LINK, refLinkOutgoing);
        TS_ASSERT(Handle::compare(refLink, Handle::UNDEFINED)); 

        }

        {
        /*
        (EvaluationLink (stv 1.0 1.0)
           (LinkGrammarRelationshipNode "Wi")
           (ListLink
              (WordInstanceNode "LEFT-WALL")
              (WordInstanceNode "go@0b75986f-7176-4f7a-8815-3f3afb0e2837")
           )
        )
        */
        Handle wiNode1 = atomSpace->getHandle(WORD_INSTANCE_NODE, "LEFT-WALL");
        TS_ASSERT(Handle::compare(wiNode1, Handle::UNDEFINED));

        Handle wiNode2 = atomSpace->getHandle(WORD_INSTANCE_NODE, "go@0b75986f-7176-4f7a-8815-3f3afb0e2837");
        TS_ASSERT(Handle::compare(wiNode1, Handle::UNDEFINED));

        HandleSeq listLinkOutgoing;
        listLinkOutgoing.push_back(wiNode1);
        listLinkOutgoing.push_back(wiNode2);
        Handle listLink = atomSpace->getHandle(LIST_LINK, listLinkOutgoing);
        TS_ASSERT(Handle::compare(listLink, Handle::UNDEFINED)); 
        
        Handle linkGrammarNode = atomSpace->getHandle(LINK_GRAMMAR_RELATIONSHIP_NODE,"Wi");
        TS_ASSERT(Handle::compare(linkGrammarNode, Handle::UNDEFINED));

        HandleSeq evalLinkOutgoing;
        evalLinkOutgoing.push_back(linkGrammarNode);
        evalLinkOutgoing.push_back(listLink);
        Handle evalLink = atomSpace->getHandle(EVALUATION_LINK, evalLinkOutgoing);
        TS_ASSERT(Handle::compare(evalLink, Handle::UNDEFINED)); 


        }
        node = atomSpace->getHandle(WORD_INSTANCE_NODE, "the@783b930d-53e1-4c0d-bd8b-8566a24fefb6");        
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        node = atomSpace->getHandle(WORD_NODE, "the");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(WORD_INSTANCE_NODE, "blue@6e8d15d0-194a-456b-b8fb-aa3ea2fa43b6");        
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        node = atomSpace->getHandle(WORD_NODE, "blue");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
    
        {
        Handle wiNode = atomSpace->getHandle(WORD_INSTANCE_NODE, "pill@a8ef64ed-535d-4c71-a961-371e60661d08");        
        TS_ASSERT(Handle::compare(wiNode, Handle::UNDEFINED));
        
        Handle node = atomSpace->getHandle(WORD_NODE, "pill");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_RELATIONSHIP_NODE, "_amod");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        Handle conceptNode1 = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, "singular");
        TS_ASSERT(Handle::compare(conceptNode1, Handle::UNDEFINED));
        
        Handle conceptNode2 = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, "noun");
        TS_ASSERT(Handle::compare(conceptNode2, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, ".n");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, "definite");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        /*
        (InheritanceLink (stv 1.0 1.0)
           (WordInstanceNode "pill@a8ef64ed-535d-4c71-a961-371e60661d08")
           (DefinedLinguisticConceptNode "singular")
        )
        ; pos (pill, noun)
        (PartOfSpeechLink (stv 1.0 1.0)
           (WordInstanceNode "pill@a8ef64ed-535d-4c71-a961-371e60661d08")
           (DefinedLinguisticConceptNode "noun")
        )
        */
        HandleSeq inLinkOutgoing;
        inLinkOutgoing.push_back(wiNode);
        inLinkOutgoing.push_back(conceptNode1);
        Handle inLink = atomSpace->getHandle(INHERITANCE_LINK, inLinkOutgoing);
        TS_ASSERT(Handle::compare(inLink, Handle::UNDEFINED));      

        HandleSeq posLinkOutgoing;
        posLinkOutgoing.push_back(wiNode);
        posLinkOutgoing.push_back(conceptNode2);
        Handle posLink = atomSpace->getHandle(PART_OF_SPEECH_LINK, posLinkOutgoing);
        TS_ASSERT(Handle::compare(posLink, Handle::UNDEFINED));      


        }

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, "adj");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, ".a");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
       
        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, "det");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_CONCEPT_NODE, ".n");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_LINGUISTIC_RELATIONSHIP_NODE, "_obj");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
       

        //frames

        {
        /*
        (FrameElementLink
           (DefinedFrameNode "#Becoming")
           (DefinedFrameElementNode "#Becoming:Entity")
        )
        */
        Handle frameNode = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Becoming");
        TS_ASSERT(Handle::compare(frameNode, Handle::UNDEFINED));

        Handle frameElementNode = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Becoming:Entity");
        TS_ASSERT(Handle::compare(frameElementNode, Handle::UNDEFINED));

        HandleSeq frameLinkOutgoing;
        frameLinkOutgoing.push_back(frameNode);
        frameLinkOutgoing.push_back(frameElementNode);
        Handle frameLink = atomSpace->getHandle(FRAME_ELEMENT_LINK, frameLinkOutgoing);
        TS_ASSERT(Handle::compare(frameLink, Handle::UNDEFINED));


        } 
        node = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Purpose");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Purpose:Goal");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        node = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Emotion_directed");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Emotion_directed:State");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Bringing");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Bringing:Theme");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Request");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Request:Message");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        node = atomSpace->getHandle(DEFINED_FRAME_NODE, "#Transitive_action");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));

        node = atomSpace->getHandle(DEFINED_FRAME_ELEMENT_NODE, "#Transitive_action:Agent");
        TS_ASSERT(Handle::compare(node, Handle::UNDEFINED));
        
        
        //TODO not all nodes checked.......

        }

        
        // process others scheme instruction message
        string schemeMsg2;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg2.xml", schemeMsg2));
        cout << "processing second scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg2.xml" << ")" << endl << schemeMsg2 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg2, toUpdateHandles));

        string schemeMsg3;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg3.xml", schemeMsg3));
        cout << "processing third scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg3.xml" << ")" << endl << schemeMsg3 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg3, toUpdateHandles));

         string schemeMsg4;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg4.xml", schemeMsg4));
        cout << "processing fourth scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg4.xml" << ")" << endl << schemeMsg4 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg4, toUpdateHandles));

        string schemeMsg5;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg5.xml", schemeMsg5));
        cout << "processing fifth scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg5.xml" << ")" << endl << schemeMsg5 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg5, toUpdateHandles));

        string schemeMsg6;
        TS_ASSERT(appendFileContent(PVP_XML_FILE_PATH "/schemeMsg6.xml", schemeMsg6));
        cout << "processing sixth scheme message (" << PVP_XML_FILE_PATH << "/schemeMsg6.xml" << ")" << endl << schemeMsg6 << endl;
        TS_ASSERT(pai.processPVPMessage(schemeMsg6, toUpdateHandles));        
    }


};

