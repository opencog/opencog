/*
 * tests/embodiment/Control/OperationalAvatarController/LanguageComprehensionUTest.cxxtest
 *
 * Copyright (C) 2009 Novamente LLC
 * All Rights Reserved
 * Author(s): Samir Araujo
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/embodiment/Control/OperationalAvatarController/LanguageComprehension.h>
#include <opencog/embodiment/Control/OperationalAvatarController/Pet.h>
#include <opencog/embodiment/Control/EmbodimentConfig.h>
#include <opencog/embodiment/AtomSpaceExtensions/AtomSpaceUtil.h>

#include <opencog/atomspace/SimpleTruthValue.h>

#include "LSMessageSenderMock.h"

#include <opencog/guile/SchemeEval.h>
#include <opencog/guile/load-file.h>

#include <opencog/query/PatternMatch.h>
#include <opencog/server/CogServer.h>
#include <opencog/persist/file/SavingLoading.h>

#include <fstream>
#include <iostream>
using namespace std;

using namespace opencog::oac;
using namespace opencog::control;

class LanguageComprehensionUTest : public CxxTest::TestSuite
{

private:
    Pet* pet;
    AtomSpace* atomSpace;
    LSMessageSenderMock* sender;

    LanguageComprehension* language;
    FramesToRelexRuleEngine* framesToRelexRuleEngine;

    const std::string petId;
    const std::string petName;
    const std::string petTraits;
    const std::string petOwner;
    const std::string petOwnerId;
    const std::string agentType;

    const std::string ballId1;
    const std::string ballId2;
    const std::string ballId3;
    const std::string ballId4;

    const std::string ballName1;
    const std::string ballName2;
    const std::string ballName3;
    const std::string ballName4;

    const std::string treeId1;
    const std::string treeId2;
    const std::string treeId3;

    const std::string stickId;
    const std::string stickName;

public:
    
    LanguageComprehensionUTest() :
        petId("1"),
        petName("Fido"),
        petTraits("maxie"),
        petOwner("Sally"),
        petOwnerId("2"),
        agentType("pet"),
        ballId1("3"),
        ballId2("4"),
        ballId3("5"),
        ballId4("6"),
        ballName1("red ball"),
        ballName2("green ball"),
        ballName3("red ball2"),
        ballName4("ball"),
        
        treeId1("7"),
        treeId2("8"),
        treeId3("9"),

        stickId("10"),
        stickName("Stick")

    {
        try {
            config().load("opencog-test.conf");
        } catch (RuntimeException &e) {
            std::cerr << e.getMessage() << std::endl;
        }
        logger().setFilename(config()["LOG_FILE"]);
        logger().setLevel(Logger::getLevelFromString(config()["LOG_LEVEL"]));
        logger().setPrintToStdoutFlag(config().get_bool("LOG_TO_STDOUT"));


        CogServer& cogserver = static_cast<CogServer&>(server());
        cogserver.loadModule( "libquery.so" );
        cogserver.loadModule( "libscheme-shell.so" );
        
        this->atomSpace = cogserver.getAtomSpace();

        config(EmbodimentConfig::embodimentCreateInstance, true);

        //set the frames2relex file to be load by the FramesToRelexRuleEngine
        config().set("FRAMES_2_RELEX_RULES_FILE", PROJECT_SOURCE_DIR"/opencog/embodiment/frames2relex.rules");

        config().set( "FRAMES_FILE",  PROJECT_SOURCE_DIR"/opencog/embodiment/frames.list" );
        config().set( "FRAMES_INHERITANCE_FILE", PROJECT_SOURCE_DIR"/opencog/embodiment/framesInheritance.list" );

        config().set( "DIALOG_CONTROLLERS", "QuestionAnswering" );

        this->sender = new LSMessageSenderMock();

        int rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/typedefs.scm");
        TSM_ASSERT_EQUALS("Failed to load type definition utilities", 0, rc);

        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/scm/utilities.scm");
        TSM_ASSERT_EQUALS("Failed to load type definition utilities", 0, rc);

        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/embodiment/scm/predicates-frames.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);

        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/embodiment/scm/language-comprehension.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/embodiment/scm/reference-resolution-rules.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/embodiment/scm/command-resolution-rules.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/opencog/embodiment/scm/question-answering.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);

        
        HandleSeq semeNodeReference(2);

        // setup agent
        Handle petNode = this->atomSpace->addNode( PET_NODE, petId );
        Handle petSemeNode = this->atomSpace->addNode( SEME_NODE, petId );
        this->atomSpace->getSpaceServer().addSpaceInfo(true, petNode, 1, 
                                      35, 60, 0, 
                                      10, 10, 10, 0, false );

        semeNodeReference[0] = petNode;
        semeNodeReference[1] = petSemeNode;
        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );

        Handle avatarNode = this->atomSpace->addNode( AVATAR_NODE, petOwnerId );
        Handle avatarSemeNode = this->atomSpace->addNode( SEME_NODE, petOwnerId );
        this->atomSpace->getSpaceServer().addSpaceInfo(true, avatarNode, 1, 
                                      200, 101, 0, 
                                      20, 20, 20, 0, true );

        semeNodeReference[0] = avatarNode;
        semeNodeReference[1] = avatarSemeNode;
        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );

        this->atomSpace->addLink( REFERENCE_LINK, avatarSemeNode,
                                  this->atomSpace->addNode( WORD_NODE, "me" ),TruthValue::TRUE_TV( ) );

        this->pet = new Pet( petId, petName, agentType, petTraits, petOwner, this->atomSpace, sender );
        this->language = new LanguageComprehension( *this->pet );

        Handle white = this->atomSpace->addNode( CONCEPT_NODE, "white" );
        Handle brown = this->atomSpace->addNode( CONCEPT_NODE, "brown" );
        Handle black = this->atomSpace->addNode( CONCEPT_NODE, "black" );
        Handle yellow = this->atomSpace->addNode( CONCEPT_NODE, "yellow" );
        Handle red = this->atomSpace->addNode( CONCEPT_NODE, "red" );
        Handle green = this->atomSpace->addNode( CONCEPT_NODE, "green" );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  white,
                                  this->atomSpace->addNode( WORD_NODE, "white" ),
                                  TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  brown,
                                  this->atomSpace->addNode( WORD_NODE, "brown" ),
                                  TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  black,
                                  this->atomSpace->addNode( WORD_NODE, "black" ),
                                  TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  yellow,
                                  this->atomSpace->addNode( WORD_NODE, "yellow" ),
                                  TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  red,
                                  this->atomSpace->addNode( WORD_NODE, "red" ),
                                  TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( REFERENCE_LINK, 
                                  green,
                                  this->atomSpace->addNode( WORD_NODE, "green" ),
                                  TruthValue::TRUE_TV( ) );

        HandleSeq wordNodeReference(2);

        wordNodeReference[1] = this->atomSpace->addNode( WORD_NODE, "tree" );        
        Handle tree1 = this->atomSpace->addNode( STRUCTURE_NODE, treeId1 );
        { // setup tree 1
            Handle semeNode = this->atomSpace->addNode( SEME_NODE, treeId1 );
            semeNodeReference[0] = tree1;
            semeNodeReference[1] = semeNode;
            
            this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );        
            
            wordNodeReference[0] = semeNode;
            this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference,TruthValue::TRUE_TV( ) );
            
            this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode, 1, 
                                          50, 60, 0, 
                                          2, 2, 30, 0, false );            
        }
        Handle tree2 = this->atomSpace->addNode( STRUCTURE_NODE, treeId2 );
        { // setup tree 2
            Handle semeNode = this->atomSpace->addNode( SEME_NODE, treeId2 );
            semeNodeReference[0] = tree2;
            semeNodeReference[1] = semeNode;
            
            this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );        
            
            wordNodeReference[0] = semeNode;
            this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference,TruthValue::TRUE_TV( ) );
            
            this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode, 1, 
                                          50, 150, 0, 
                                          2, 2, 30, 0, false );            
        }
        Handle tree3 = this->atomSpace->addNode( STRUCTURE_NODE, treeId3 );
        { // setup tree 3
            Handle semeNode = this->atomSpace->addNode( SEME_NODE, treeId3 );
            semeNodeReference[0] = tree3;
            semeNodeReference[1] = semeNode;
            
            this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );        
            
            wordNodeReference[0] = semeNode;
            this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference,TruthValue::TRUE_TV( ) );
            
            this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode, 1, 
                                          50, 200, 0, 
                                          2, 2, 30, 0, false );            
        }

        wordNodeReference[1] = this->atomSpace->addNode( WORD_NODE, "ball" );
        
        // setup ball 1
        Handle semeNode1 = this->atomSpace->addNode( SEME_NODE, ballId1 );
        Handle ball1 = this->atomSpace->addNode( ACCESSORY_NODE, ballId1 );
        semeNodeReference[0] = ball1;
        semeNodeReference[1] = semeNode1;

        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );        
        this->atomSpace->addLink( WR_LINK, this->atomSpace->addNode( WORD_NODE, ballName1 ), ball1 );

        wordNodeReference[0] = semeNode1;
        this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference,TruthValue::TRUE_TV( ) );


        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "color", TruthValue::TRUE_TV( ), ball1 , red );
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = semeNode1;
            elements["Color"] = red;
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Color", 
                                                        "colorBall1", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }

        this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode1, 1, 
                                      10, 10, 0, 
                                      2, 2, 2, 0, false );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.23, 1.0), ball1, petNode );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.23, 1.0), petNode, ball1 );

        // setup ball 2
        Handle semeNode2 = this->atomSpace->addNode( SEME_NODE, ballId2 );
        Handle ball2 = this->atomSpace->addNode( ACCESSORY_NODE, ballId2 );
        semeNodeReference[0] = ball2;
        semeNodeReference[1] = semeNode2;
        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference, TruthValue::TRUE_TV( ) );        
        this->atomSpace->addLink( WR_LINK, this->atomSpace->addNode( WORD_NODE, ballName2 ), ball2 );

        wordNodeReference[0] = semeNode2;
        this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference, TruthValue::TRUE_TV( ) );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "color", TruthValue::TRUE_TV( ), ball2, green );
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = semeNode2;
            elements["Color"] = green;
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Color", 
                                                        "colorBall2", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }

        this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode2, 1, 
                                      50, 50, 0, 
                                      2, 2, 2, 0, false );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.1, 1.0), ball2, petNode );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.1, 1.0), petNode, ball2 );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 1.0, 1.0), ball2, tree2 );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 1.0, 1.0), tree2, ball2 );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "next", SimpleTruthValue( 1.0, 1.0), ball2, tree2 );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "next", SimpleTruthValue( 1.0, 1.0), tree2, ball2 );


        // setup ball 3
        Handle semeNode3 = this->atomSpace->addNode( SEME_NODE, ballId3 );
        Handle ball3 = this->atomSpace->addNode( ACCESSORY_NODE, ballId3 );
        semeNodeReference[0] = ball3;
        semeNodeReference[1] = semeNode3;
        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference, TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( WR_LINK, this->atomSpace->addNode( WORD_NODE, ballName3 ), ball3 );

        wordNodeReference[0] = semeNode3;
        this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference, TruthValue::TRUE_TV( ) );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "color", TruthValue::TRUE_TV( ), ball3, red );
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = semeNode3;
            elements["Color"] = red;
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Color", 
                                                        "colorBall3", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }
        this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode3, 1, 
                                      45, 100, 0, 
                                      2, 2, 2, 0, false );
        
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.6, 1.0), ball3, petNode );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "near", SimpleTruthValue( 0.6, 1.0), petNode, ball3 );

        // setup stick
        Handle semeNodeStick = this->atomSpace->addNode( SEME_NODE, stickId );
        Handle stickHandle = this->atomSpace->addNode( ACCESSORY_NODE, stickId );
        semeNodeReference[0] = stickHandle;
        semeNodeReference[1] = semeNodeStick;

        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference,TruthValue::TRUE_TV( ) );        
        this->atomSpace->addLink( WR_LINK, this->atomSpace->addNode( WORD_NODE, stickName ), stickHandle );

        wordNodeReference[0] = semeNodeStick;
        this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference,TruthValue::TRUE_TV( ) );


        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "color", TruthValue::TRUE_TV( ), stickHandle , brown );
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = semeNodeStick;
            elements["Color"] = brown;
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Color", 
                                                        "colorStick", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
                                                        
        }


        // setup ball 4
        Handle semeNode4 = this->atomSpace->addNode( SEME_NODE, ballId4 );
        Handle ball4 = this->atomSpace->addNode( ACCESSORY_NODE, ballId4 );
        semeNodeReference[0] = ball4;
        semeNodeReference[1] = semeNode4;
        this->atomSpace->addLink( REFERENCE_LINK, semeNodeReference, TruthValue::TRUE_TV( ) );
        this->atomSpace->addLink( WR_LINK, this->atomSpace->addNode( WORD_NODE, ballName4 ), ball4 );

        wordNodeReference[0] = semeNode4;
        this->atomSpace->addLink( REFERENCE_LINK, wordNodeReference, TruthValue::TRUE_TV( ) );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "color", TruthValue::TRUE_TV( ), ball4, white );
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = semeNode4;
            elements["Color"] = white;
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Color", 
                                                        "colorBall4", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
                                                        
        }

        this->atomSpace->getSpaceServer().addSpaceInfo(true, semeNode4, 1, 
                                      40, 105, 0, 
                                      2, 2, 2, 0, false );
        
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "next", SimpleTruthValue( 0.6, 1.0), ball4, petNode );
        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "next", SimpleTruthValue( 0.6, 1.0), petNode, ball4 );

        { // create a dump of the map
            std::ofstream file("testMapDump.txt");
            file << spatial::LocalSpaceMap2D::toString( this->atomSpace->getSpaceServer( ).getLatestMap( ) );
            file.close();
        } // end block
            
       
    }

    ~LanguageComprehensionUTest( ) 
    {
        delete this->language;
        delete this->pet;
        delete this->atomSpace;
        delete this->sender;
    }

    void setUp() 
    {
        
    }

    void tearDown() 
    {
    }

    void testResolution( ) 
    {
 
        // first call it without sentence to parse
        this->language->resolveLatestSentenceReference( );
        // testing: grab the red ball
        int rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence1.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);

        this->language->resolveLatestSentenceReference( );
        {
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, ballId3 ) );
            semeNodeBind.push_back( Handle::UNDEFINED  );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the ball 3 was chosen as the correct ball
            TS_ASSERT( response.size( ) == 1 );
        }
        this->language->resolveLatestSentenceCommand( );
        {
            HandleSeq arguments(1);
            arguments[0] = this->atomSpace->addNode( ACCESSORY_NODE, ballId3);
            HandleSeq command(2);
            command[0] = this->atomSpace->addNode( GROUNDED_SCHEMA_NODE, "goto_object_and_grabit");
            command[1] = this->atomSpace->getHandle( LIST_LINK, arguments );
            
            Handle execLink = this->atomSpace->getHandle( EXECUTION_LINK, command );
            TS_ASSERT( this->atomSpace->getTV( execLink )->getMean( ) > 0 );
            TS_ASSERT( execLink != Handle::UNDEFINED );
        }

        // testing: bring it to me
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence2.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);

        this->language->resolveLatestSentenceReference( );
        
        {
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, petOwnerId ) );
            semeNodeBind.push_back( Handle::UNDEFINED );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the avatar was chosen as the correct me
            TS_ASSERT( response.size( ) == 1 );

        }
        { // checking anaphora resolution
            
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, ballId3 ) );
            semeNodeBind.push_back( Handle::UNDEFINED );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the ball 3 was chosen as the correct 'it' and 'ball'
            TS_ASSERT( response.size( ) == 2 );
        } // end block        
        
        // testing: drop it
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence3.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );        
        { // checking anaphora resolution
            
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, ballId3 ) );
            semeNodeBind.push_back( Handle::UNDEFINED );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the ball 3 was chosen as the correct 'it' and 'ball'
            TS_ASSERT( response.size( ) == 3 );
        } // end block        
        this->language->resolveLatestSentenceCommand( );
        {
            HandleSeq arguments;
            HandleSeq command(2);
            command[0] = this->atomSpace->addNode( GROUNDED_SCHEMA_NODE, "drop");
            command[1] = this->atomSpace->getHandle( LIST_LINK, arguments );
            
            Handle execLink = this->atomSpace->getHandle( EXECUTION_LINK, command );
            TS_ASSERT( this->atomSpace->getTV( execLink )->getMean( ) > 0 );
            TS_ASSERT( execLink != Handle::UNDEFINED );
        }

        // testing: go to the red ball
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence4.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );
        { // checking anaphora resolution
            
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, ballId3 ) );
            semeNodeBind.push_back( Handle::UNDEFINED );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the ball 3 was chosen as the correct 'it' and 'ball'
            TS_ASSERT( response.size( ) == 4 );
        } // end block        
        this->language->resolveLatestSentenceCommand( );        
        {
            HandleSeq arguments(1);
            arguments[0] = this->atomSpace->addNode( ACCESSORY_NODE, ballId3);
            HandleSeq command(2);
            command[0] = this->atomSpace->addNode( GROUNDED_SCHEMA_NODE, "walkto_obj");
            command[1] = this->atomSpace->getHandle( LIST_LINK, arguments );
            
            Handle execLink = this->atomSpace->getHandle( EXECUTION_LINK, command );
            TS_ASSERT( this->atomSpace->getTV( execLink )->getMean( ) > 0 );
            TS_ASSERT( execLink != Handle::UNDEFINED );
        }
        
        // testing: grab the white ball
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence5.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );
        { // checking anaphora resolution
            
            HandleSeq semeNodeBind;
            semeNodeBind.push_back( this->atomSpace->getHandle( SEME_NODE, ballId4 ) );
            semeNodeBind.push_back( Handle::UNDEFINED );
        
            Type types[] = { SEME_NODE, WORD_INSTANCE_NODE };
            HandleSeq response;
            this->atomSpace->getHandleSet( back_inserter(response),
                                           semeNodeBind, &types[0], NULL, 
                                           2, REFERENCE_LINK, false );
            // if the test succeed, the reference resolution worked well
            // and the ball 6 was chosen as the correct 'ball' for both parses
            TS_ASSERT( response.size( ) == 2 );
        } // end block        
        this->language->resolveLatestSentenceCommand( );
        {

            HandleSeq arguments(1);
            arguments[0] = this->atomSpace->addNode( ACCESSORY_NODE, "6");
            HandleSeq command(2);
            command[0] = this->atomSpace->addNode( GROUNDED_SCHEMA_NODE, "goto_object_and_grabit");
            command[1] = this->atomSpace->getHandle( LIST_LINK, arguments );
            
            Handle execLink = this->atomSpace->getHandle( EXECUTION_LINK, command );
            TS_ASSERT( this->atomSpace->getTV( execLink )->getMean( ) > 0 );
            TS_ASSERT( execLink != Handle::UNDEFINED );
        }



        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence7.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );
        this->language->updateFact( );
        Handle colorFrame = this->atomSpace->getHandle( PREDICATE_NODE, 
            "G_green@fba0ea8f-ce96-4c3e-b1a3-0dbe4e70bbcb_Color");
        Handle attributesFrame = this->atomSpace->getHandle( PREDICATE_NODE, 
            "G_green@fba0ea8f-ce96-4c3e-b1a3-0dbe4e70bbcb_Attributes");

        TS_ASSERT( colorFrame != Handle::UNDEFINED )
        TS_ASSERT( attributesFrame != Handle::UNDEFINED )

        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-sentence8.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );
        this->language->updateFact( );       
        
        TS_ASSERT( this->atomSpace->getIncoming( colorFrame ).size( ) == 0 )
        TS_ASSERT( this->atomSpace->getIncoming( attributesFrame ).size( ) == 0 )        


    } 

    
    void testQuestionAnswering( void )
    {

        int rc;        
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = this->atomSpace->addNode( SEME_NODE, "1");
            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Entity", 
                                                        "storedEntity", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }
        {
            std::map<std::string, Handle> elements;
            elements["Entity"] = this->atomSpace->addNode( SEME_NODE, "1");
            elements["Name"] = this->atomSpace->addNode( CONCEPT_NODE, "Fido");

            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Entity", 
                                                        "storedEntity3", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }
        {
            std::map<std::string, Handle> elements;
            elements["Experiencer"] = this->atomSpace->addNode( SEME_NODE, "1");
            elements["State"] = this->atomSpace->addNode( CONCEPT_NODE, "anger");

            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Emotion_directed", 
                                                        "angryFido", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }

        
        {
            std::map<std::string, Handle> elements;
            elements["Experiencer"] = this->atomSpace->addNode( SEME_NODE, "1");
            elements["State"] = this->atomSpace->addNode( CONCEPT_NODE, "pride");

            AtomSpaceUtil::setPredicateFrameFromHandles(*atomSpace, 
                                                        "#Emotion_directed", 
                                                        "proudFido", 
                                                        elements, 
                                                        SimpleTruthValue(1.0, 1.0) );
        }

        Handle agentHandle = this->atomSpace->getHandle( PET_NODE, petId );

        setHeardSentence( "are you angry?" );

        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question6.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        TS_ASSERT( AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        TS_ASSERT( pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ) == "Yes" )

        AtomSpaceUtil::setPredicateValue( *atomSpace, "has_something_to_say", TruthValue::FALSE_TV(), 
            agentHandle );

        setHeardSentence( "are you hungry?" );
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question7.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        TS_ASSERT( AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        TS_ASSERT( pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ) == "No" )

        
        setHeardSentence( "are you proud?" );
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question8.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        TS_ASSERT( AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        TS_ASSERT( pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ) == "Yes" )
        

        setHeardSentence( "what color is the ball?" );
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question9.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        TS_ASSERT( AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        TS_ASSERT( pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ) != "" )
        logger().debug("Question 9 Answer: %s",pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ).c_str());
    
        setHeardSentence( "what color is the stick?" );
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question10.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        TS_ASSERT( AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        //TS_ASSERT( pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ) == "Yes" )    
        logger().debug("Question 10 Answer: %s",pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ).c_str());

        setHeardSentence( "what is behind the tree?" );
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question11.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        this->language->resolveLatestSentenceReference( );

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 

        AtomSpaceUtil::setPredicateValue( *atomSpace, 
            "has_something_to_say", TruthValue::FALSE_TV( ), agentHandle );
        this->language->answerQuestion(); 
        TS_ASSERT( !AtomSpaceUtil::isPredicateTrue( *atomSpace, "has_something_to_say", 
            agentHandle ) )
        logger().debug("Question 11 Answer: %s",pet->getCurrentModeHandler( ).getPropertyValue( "customMessage" ).c_str());
    
    }
    
    
    //void testRealSituation( void ) 
    //{      
    /*
        // this test can be used to evaluate the latest sentence
        // stored into the agent atomTable. To use it copy
        // the content of the dir /tmp/<user>/opencog/agent_db/pet_id_xxxxx/
        // to the bin dir of this test and change the id in the Pet class instantiation
        // bellow. Compile and run the test
        SavingLoading savingLoading;
        savingLoading.load( "atomSpace.dump", *this->atomSpace );
        
        Pet* pet = Pet::importFromFile( "pet.dump", "id_62862", this->atomSpace, sender );
        
        LanguageComprehension lang( *pet );
        int rc;
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/scm/utilities.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/tests/scm/typedefs.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/embodiment/scm/predicates-frames.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/embodiment/scm/language-comprehension.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/embodiment/scm/reference-resolution-rules.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/embodiment/scm/command-resolution-rules.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        rc = load_scm_file( PROJECT_SOURCE_DIR"/opencog/embodiment/scm/question-answering.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);
        
        lang.resolveLatestSentenceReference( );
        lang.resolveLatestSentenceCommand( );

        
        delete pet;
    */
    //}      

    void testFrames2Sentence()
    {  
        //color
        int rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question1.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);     

        std::string output = this->language->resolveFrames2Sentence( );
        TS_ASSERT(output != "");
        logger().debug("testFrames2Sentence - Relex Output for relex-question1.scm input: %s",output.c_str() );

        output = this->language->resolveFrames2Sentence( );
        TS_ASSERT(output != "");
        logger().debug("testFrames2Sentence - Relex Output for relex-question3.scm input: %s",output.c_str() );

        //hungry
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question4.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);          

        output = this->language->resolveFrames2Sentence( );
        TS_ASSERT(output != "");
        logger().debug("testFrames2Sentence - Relex Output for relex-question4.scm input: %s",output.c_str() );
       
        //two colors
        rc = load_scm_file(*(this->atomSpace),PROJECT_SOURCE_DIR"/tests/scm/relex-question5.scm");
        TSM_ASSERT_EQUALS("Failed to load scheme file", 0, rc);          

        output = this->language->resolveFrames2Sentence( );
        TS_ASSERT(output != "");
        logger().debug("testFrames2Sentence - Relex Output for relex-question5.scm input: %s",output.c_str() );
                
    }

    void testSpatialRelationsExtractor( void ) 
    {
#ifdef HAVE_GUILE
        std::stringstream command;
        command << "(cog-emb-compute-spatial-relations ";
        command << "   (AvatarNode \"" << petOwnerId << "\")";
        command << "   (SemeNode \""<< petId << "\")";
        command << "   (SemeNode \""<< treeId1 << "\")";
        command << ")";        

        std::string answer = SchemeEval::instance( ).eval( command.str( ) );
        if ( SchemeEval::instance().eval_error() ) {
            logger().error( answer );
            SchemeEval::instance().clear_pending();
        } // if

        Handle frameInstancePredicate = this->atomSpace->getHandle( PREDICATE_NODE, petId + "_" + treeId1 + "_beside" );
        TS_ASSERT( frameInstancePredicate != Handle::UNDEFINED )
        if ( frameInstancePredicate != Handle::UNDEFINED ) {
            std::map<std::string, Handle> values = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, frameInstancePredicate );
            TS_ASSERT_EQUALS( values["Relation_type"], this->atomSpace->getHandle( CONCEPT_NODE, "beside" ) )
            TS_ASSERT_EQUALS( values["Figure"], this->atomSpace->getHandle( SEME_NODE, petId ) )
            TS_ASSERT_EQUALS( values["Ground"], this->atomSpace->getHandle( SEME_NODE, treeId1 ) )
        } // if        
#endif
    }

    void testSpatialRelationsEvaluator( void )
    {
#ifdef HAVE_GUILE
        std::stringstream command;
        command << "(cog-emb-compute-spatial-relations ";
        command << "   (AvatarNode \"" << petOwnerId << "\")";
        command << "   (SemeNode \""<< petId << "\")";
        command << "   (SemeNode \""<< treeId1 << "\")";
        command << ")";
        
        
        std::string answer = SchemeEval::instance( ).eval( command.str( ) );
        if ( SchemeEval::instance().eval_error() ) {
            logger().error( answer );
            SchemeEval::instance().clear_pending();
        } // if

        Handle frameInstancePredicate = this->atomSpace->getHandle( PREDICATE_NODE, petId + "_" + treeId1 + "_behind" );
        TS_ASSERT( frameInstancePredicate != Handle::UNDEFINED )
        if ( frameInstancePredicate != Handle::UNDEFINED ) {
            std::map<std::string, Handle> values = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, frameInstancePredicate );
            TS_ASSERT_EQUALS( values["Relation_type"], this->atomSpace->getHandle( CONCEPT_NODE, "behind" ) )
            TS_ASSERT_EQUALS( values["Figure"], this->atomSpace->getHandle( SEME_NODE, petId ) )
            TS_ASSERT_EQUALS( values["Ground"], this->atomSpace->getHandle( SEME_NODE, treeId1 ) )
        } // if
#endif
    }

    void testFramePredicates()
    {
        Handle petH   = atomSpace->addNode( SEME_NODE, petId);
        Handle ownerH = atomSpace->addNode( SEME_NODE, petOwnerId);
        Handle stickH = atomSpace->addNode( SEME_NODE, stickId);

        Handle is_near = atomSpace->addNode( CONCEPT_NODE, "is_near" );

        std::map<std::string, Handle> elements;
        elements["Figure"] = petH;
        elements["Ground"] = ownerH;
        elements["Relation_type"] = is_near;
        
        
        
        Handle isNearFrameInstance = AtomSpaceUtil::setPredicateFrameFromHandles( 
            *atomSpace, "#Locative_relation", "is_near", 
                elements, SimpleTruthValue(1.0, 1.0) );

        TS_ASSERT( isNearFrameInstance != Handle::UNDEFINED );
        {
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance );
            TS_ASSERT_EQUALS( elements, storedElements )
        }
        std::map<std::string, Handle> elements2;
        elements2["Figure"] = stickH;
        elements2["Ground"] = petH;
        elements2["Relation_type"] = is_near;

        Handle isNearFrameInstance2 = AtomSpaceUtil::setPredicateFrameFromHandles( 
            *atomSpace, "#Locative_relation", "is_near", 
                elements2, SimpleTruthValue(1.0, 1.0) );        
        TS_ASSERT( isNearFrameInstance2 != Handle::UNDEFINED );
        {
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance2 );
            TS_ASSERT_EQUALS( elements2, storedElements )
        }

        {
            HandleSeq isNearInstances =
                AtomSpaceUtil::retrieveFrameInstancesUsingAnElementValue( *atomSpace, "#Locative_relation", is_near );
            
            TS_ASSERT( isNearInstances.size( ) > 0 )
            if ( isNearInstances.size( ) > 0 ) {
                std::map<std::string, Handle> storedElements = 
                    AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearInstances[isNearInstances.size()-1] );
                TS_ASSERT_EQUALS( elements2, storedElements )
            } // if                        
        }

        {
            HandleSeq isNearInstances =
                AtomSpaceUtil::retrieveFrameInstancesUsingAnElementValue( *atomSpace, "#Locative_relation", petH );

            TS_ASSERT( isNearInstances.size( ) == 4 )
            if ( isNearInstances.size( ) == 1 ) {
                std::map<std::string, Handle> storedElements = 
                    AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearInstances[0] );
                TS_ASSERT_EQUALS( elements2, storedElements )
            } // if
            
        }        
        
        // test Figure
        HandleSeq figureTest;
        figureTest.push_back( atomSpace->getHandle( PREDICATE_NODE, "is_near_Figure" ) );
        figureTest.push_back( Handle::UNDEFINED );        
        HandleSeq figureHandles;
        atomSpace->getHandleSet(back_inserter(figureHandles),
                                figureTest, NULL, NULL, 2, EVALUATION_LINK, false);        
        TS_ASSERT( figureHandles.size( ) == 1 );
        TS_ASSERT( figureHandles[0] != Handle::UNDEFINED );            
        TS_ASSERT_EQUALS( atomSpace->getOutgoing( figureHandles[0], 1 ), stickH );
        
        // test Ground
        HandleSeq groundTest;
        groundTest.push_back( atomSpace->getHandle( PREDICATE_NODE, "is_near_Ground" ) );
        groundTest.push_back( Handle::UNDEFINED );        
        HandleSeq groundHandles;
        atomSpace->getHandleSet(back_inserter(groundHandles),
                                groundTest, NULL, NULL, 2, EVALUATION_LINK, false);        
        TS_ASSERT( groundHandles.size( ) == 1 );
        TS_ASSERT( groundHandles[0] != Handle::UNDEFINED );
        TS_ASSERT_EQUALS( atomSpace->getOutgoing( groundHandles[0], 1 ), petH );


        // test Relation_type
        HandleSeq relationTypeTest;
        relationTypeTest.push_back( atomSpace->getHandle( PREDICATE_NODE, "is_near_Relation_type" ) );
        relationTypeTest.push_back( Handle::UNDEFINED );        
        HandleSeq relationTypeHandles;
        atomSpace->getHandleSet(back_inserter(relationTypeHandles),
                                relationTypeTest, NULL, NULL, 2, EVALUATION_LINK, false);        
        TS_ASSERT( relationTypeHandles.size( ) == 1 );
        TS_ASSERT( relationTypeHandles[0] != Handle::UNDEFINED );            
        TS_ASSERT_EQUALS( atomSpace->getOutgoing( relationTypeHandles[0], 1 ), is_near );
        
        // test re-creating the instance with fewer elements
        std::map<std::string, Handle> elements3;
        elements3["Figure"] = stickH;
        elements3["Relation_type"] = is_near;

        Handle isNearFrameInstance3 = AtomSpaceUtil::setPredicateFrameFromHandles( 
            *atomSpace, "#Locative_relation", "is_near", 
                elements3, SimpleTruthValue(1.0, 1.0) );        
        TS_ASSERT( isNearFrameInstance3 != Handle::UNDEFINED );
        {
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance3 );
            TS_ASSERT_EQUALS( elements3, storedElements )
        }

        // test removing an element using UNDEFINED for its value and re-ading
        // an element previously removed
        std::map<std::string, Handle> elements4;
        elements4["Figure"] = stickH;
        elements4["Ground"] = petH;
        elements4["Relation_type"] = Handle::UNDEFINED;

        std::map<std::string, Handle> elements5;
        elements5["Figure"] = stickH;
        elements5["Ground"] = petH;

        Handle isNearFrameInstance4 = AtomSpaceUtil::setPredicateFrameFromHandles( 
            *atomSpace, "#Locative_relation", "is_near", 
                elements4, SimpleTruthValue(1.0, 1.0) );        
        TS_ASSERT( isNearFrameInstance4 != Handle::UNDEFINED );
        {
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance4 );
            TS_ASSERT_EQUALS( elements5, storedElements )
        }

        // test re-creating the instance with fewer elements
        std::map<std::string, Handle> elements6;
        elements6["Figure"] = stickH;
        elements6["Relation_type"] = is_near;
        elements6["inexistent_element1"] = petH;
        elements6["inexistent_element2"] = ownerH;

        Handle isNearFrameInstance6 = AtomSpaceUtil::setPredicateFrameFromHandles( 
            *atomSpace, "#Locative_relation", "is_near", 
                elements6, SimpleTruthValue(1.0, 1.0) );        
        TS_ASSERT( isNearFrameInstance6 != Handle::UNDEFINED );
        {
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance6 );
            TS_ASSERT_EQUALS( elements3, storedElements )
        }

        // test removing frameInstance
        {
            AtomSpaceUtil::deleteFrameInstance( *atomSpace, isNearFrameInstance2 );
            
            std::map<std::string, Handle> storedElements = 
                AtomSpaceUtil::getFrameElementInstanceNameValues( *atomSpace, isNearFrameInstance2 );
            TS_ASSERT( storedElements.size( ) == 0 )
        }
    }

    void setHeardSentence( const std::string& sentence, bool isQuestion = true )
    {
        std::stringstream finalSentence;
        finalSentence << "to:" << this->pet->getPetId( );
        finalSentence << ": " << sentence;
        Handle sentenceNode = 
            AtomSpaceUtil::addNode( *this->atomSpace, SENTENCE_NODE, finalSentence.str( ) );

        AtomSpaceUtil::setPredicateValue( *this->atomSpace, "heard_sentence",
            TruthValue::TRUE_TV( ), sentenceNode );

        if ( isQuestion ) {
            AtomSpaceUtil::setPredicateValue( *this->atomSpace, "is_question",
                TruthValue::TRUE_TV( ), sentenceNode );
        } // if
    }


}; 
