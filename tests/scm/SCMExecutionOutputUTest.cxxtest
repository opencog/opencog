/*
 * tests/scm/SCMExecutionOutputUTest.cxxtest
 *
 * Copyright (C) 2014 Cosmo Harrigan, Linas Vepstas
 * Copyright (C) 2015 Linas Vepstas
 * All Rights Reserved
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atomspace/AtomSpace.h>
#include <opencog/atomspace/Link.h>
#include <opencog/atomspace/Node.h>
#include <opencog/guile/SchemeSmob.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/guile/SchemePrimitive.h>
#include <opencog/server/CogServer.h>
#include <opencog/util/Logger.h>
#include <opencog/util/Config.h>
#include <opencog/execution/ExecutionOutputLink.h>

using namespace opencog;

class SCMExecutionOutputUTest :  public CxxTest::TestSuite
{
	private:
		AtomSpace *as;
		SchemeEval *eval;

	public:

	SCMExecutionOutputUTest(void)
	{
		try
		{
			config().load("opencog-test.conf");
		}
		catch (RuntimeException &e)
		{
			std::cerr << e.getMessage() << std::endl;
		}
		logger().setFilename(config()["LOG_FILE"]);
		logger().setLevel(Logger::getLevelFromString(config()["LOG_LEVEL"]));
		logger().setPrintToStdoutFlag(config().get_bool("LOG_TO_STDOUT"));

        config().set("SCM_PRELOAD", "opencog/atomspace/core_types.scm");

        cogserver().loadSCMModules();
	}

	~SCMExecutionOutputUTest()
	{
		// erase the log file if no assertions failed
		if (!CxxTest::TestTracker::tracker().suiteFailed())
			std::remove(logger().getFilename().c_str());
	}

	void setUp(void);
	void tearDown(void);

	void test_execute(void);

	void test_multi_threads(void);
	void threadedAdd(int thread_id, int N);

	void test_recursive(void);
	void test_nested(void);
};

void SCMExecutionOutputUTest::setUp(void)
{
	server(CogServer::createInstance);
	as = &cogserver().getAtomSpace();
	eval = new SchemeEval(as);
}

void SCMExecutionOutputUTest::tearDown(void)
{
	delete eval;
	eval = NULL;
}

#define CHKEV(ev) \
	TSM_ASSERT("Caught scm error during eval", \
		(false == ev->eval_error()));
void SCMExecutionOutputUTest::test_execute(void)
{
	Handle julian = as->addNode(CONCEPT_NODE, "julian");
	Handle prince = as->addNode(CONCEPT_NODE, "prince");
	Handle king = as->addNode(CONCEPT_NODE, "king");
	as->addLink(INHERITANCE_LINK, julian, prince);

	// Define a Scheme procedure that will be used in the
	// GroundedSchemaNode
	eval->eval("(define (make-king x) (InheritanceLink x "
	           "(ConceptNode \"king\")))");
	CHKEV(eval);

	// There is no king yet
	TS_ASSERT_EQUALS(as->getIncoming(king).size(), 0);

	// Use the "cog-execute!" command to fire an ExecutionOutputLink directly
	// from the Scheme shell, containing a GroundedSchemaNode referring to
	// the previously defined procedure
	eval->eval("(cog-execute! (ExecutionOutputLink "
	           "(GroundedSchemaNode \"scm: make-king\") (ListLink "
	           "(ConceptNode \"julian\"))))");
	CHKEV(eval);

	// Now there should be a king
	TS_ASSERT_EQUALS(as->getIncoming(king).size(), 1);
}


// In this thread, do same as above, esxcept make lots of Julians,
// and crown them all.
// Use a unique evaluator for this thread.
void SCMExecutionOutputUTest::threadedAdd(int thread_id, int N)
{
	AtomSpace* as = &cogserver().getAtomSpace();
	SchemeEval* ev = get_evaluator(as);
	int counter = 0;

	// Define a Scheme procedure that will be used in the
	// GroundedSchemaNode
	ev->eval("(define (make-king x) (InheritanceLink x "
	         "(ConceptNode \"king\")))");

	for (int i = 0; i < N; i++) {
		double strength = 0.7 * ((double) i) / ((double) N);
		double confidence = 0.8 * ((double) N-i) / ((double) N);

		std::ostringstream jules;
		jules << "\"julian " << thread_id << " node " << counter << "\"";
		counter ++;

		std::ostringstream oss;
		oss << "(InheritanceLink (ConceptNode "
		    << jules.str() << ")"
		    << "(ConceptNode \"prince\")"
		    << "(cog-new-stv " << strength << " " << confidence << "))";

		Handle h = ev->eval_h(oss.str());
		CHKEV(ev);
		TSM_ASSERT("Failed to create atom", Handle::UNDEFINED != h);

		// Use the "cog-execute!" command to fire an ExecutionOutputLink directly
		// from the Scheme shell, containing a GroundedSchemaNode referring to
		// the previously defined procedure
		std::ostringstream ess;
		ess << "(cog-execute! (ExecutionOutputLink "
		       "(GroundedSchemaNode \"scm: make-king\") "
             "(ListLink (ConceptNode " << jules.str() << "))))";
		ev->eval(ess.str());
		CHKEV(eval);
	}
}

/*
 * Test multiple evaluators writing to a single atomspace, in multiple threads.
 * This is the same as testExecute above, except here, we have a zillian
 * different julians all being crowned king.  We use 8 threads in which to do
 * the crowning.
 */
void SCMExecutionOutputUTest::test_multi_threads(void)
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);
	AtomSpace* as = &cogserver().getAtomSpace();
	as->clear();

	std::vector<std::thread> thread_pool;

	int n_threads = 8;
	int num_atoms = 100;
	for (int i=0; i < n_threads; i++) {
		thread_pool.push_back(
			std::thread(&SCMExecutionOutputUTest::threadedAdd, this, i, num_atoms));
	}
	for (std::thread& t : thread_pool) t.join();
	size_t size = as->getSize();
	std::cout << "atomspace size:" << size << std::endl;

	// we should get ... a total of ...
	// 1 prince
	// 1 grounded schema
	// 1 king
	// num_atoms * n_threads  Concept    julians
	// num_atoms * n_threads  Inheritance  julian prince
	// num_atoms * n_threads  ListLink  julian
	// num_atoms * n_threads  ExecutionOutputLink
	// num_atoms * n_threads  Inheritance  julian king
	// for a total of 3 + 5 * num_atoms * n_threads atoms created, total.
	TS_ASSERT_EQUALS(size, 5 * num_atoms * n_threads + 3);

	// Everyone gets to be a king!  Yayyyy!
	Handle king = as->addNode(CONCEPT_NODE, "king");
	TS_ASSERT_EQUALS(as->getIncoming(king).size(), num_atoms * n_threads);

	logger().debug("END TEST: %s", __FUNCTION__);
}

// This tests a tail-recursive invocation of nested
// ExectutionOutputLinks, with an intervening cog-execute! at each step.
// Thus, this winds up the C++ stack for the recursion.
void SCMExecutionOutputUTest::test_recursive(void)
{
	// Empty out the atomspace
	as->clear();
	size_t size = as->getSize();
	TS_ASSERT_EQUALS(size, 0);

	// Define various generic utilities
	eval->eval(
		"(define (make-king x)"
		"   (InheritanceLink x (ConceptNode \"king\")))"
		"(define (make-queen x)"
		"   (InheritanceLink x (ConceptNode \"queen\")))"
		"(define (stv mean conf) (cog-new-stv mean conf))"
		"(define (tv-mean tv) (assoc-ref (cog-tv->alist tv) 'mean))"
		"(define (tv-conf tv) (assoc-ref (cog-tv->alist tv) 'confidence))"
	);
	CHKEV(eval);

	// Every time this is called, atom x becomes more royal.
	// viz the atom TV mean is incremented by cnt
	eval->eval(
		"(define (royal-incr atom cnt)"
		"   (cog-set-tv! atom"
		"       (stv (+ (tv-mean (cog-tv atom)) cnt)"
		"           (tv-conf (cog-tv atom)))))"
	);
	CHKEV(eval);

	// If the atom's tv-mean is greater than 0.9, the atom is crowned
	// king.  Otherwise, the mean is incremented by 0.1.
	// Note that this is (tail-)recursive, for about 9 steps:
	// That is, 0.9/0.1 = 9.
	eval->eval(
		"(define (royalize x)"
		"   (if (> (tv-mean (cog-tv x)) 0.9)"
		"      (make-king x)"
		"      (royalize (royal-incr x 0.1))))"
	);
	CHKEV(eval);

	// Same as above, except that the recursion is done by execution
	// link. The incr is 0.01, which will cause a total of about 90
	// recursive calls before Barbie marries the prince.  That is,
	// 0.9 / 0.01 = 90.  Although this is tail-recursive from the
	// scheme point of view, the C++ stack will grow, because each
	// invocation of cog-execute! pushes a stack frame for
	// ExecutionOutputLink::do_execute() onto the stack.
	eval->eval(
		"(define (promote x)"
		"   (if (> (tv-mean (cog-tv x)) 0.9)"
		"      (make-queen x)"
		"      (exe-royalize (royal-incr x 0.01))))"
	);
	CHKEV(eval);

	// Wrap royalize with an execution link
	eval->eval(
		"(define (exe-royalize princess)"
		"   (cog-execute! "
		"      (ExecutionOutputLink "
		"         (GroundedSchemaNode \"scm: promote\")"
		"         (ListLink princess))))"
	);

	// Start out with Julian a newborn prince.
	eval->eval(
		"(define julian (ConceptNode \"julian\" (stv 0 0)))"
	);
	CHKEV(eval);

	// Initially, atomspace has one atom: just julian
	size = as->getSize();
	TS_ASSERT_EQUALS(size, 1);

	eval->eval(
		"(royalize julian)"
	);
	CHKEV(eval);

	// Now, the atomspace has three atoms (Inheritance julian king)
	size = as->getSize();
	TS_ASSERT_EQUALS(size, 3);

	// Start out with Anneliese a newborn princess.
	eval->eval(
		"(define anne (ConceptNode \"Anneliese\" (stv 0 0)))"
	);
	CHKEV(eval);
	size = as->getSize();
	TS_ASSERT_EQUALS(size, 4);

	eval->eval(
		"(exe-royalize anne)"
	);
	CHKEV(eval);

	// Now, the atomspace has nine atoms
	// 3:  (Inheritance julian king)
	// 3:  (Inheritance anne queen)
	// 3:  (ExecutionLink (GroundedSchemaNode) (ListLink anne))
	size = as->getSize();
	TS_ASSERT_EQUALS(size, 9);

	size = as->getSize();
}

// Test nested execution links. github issue #1340
//
// The following should work:
//   ExecutionOutputLink
//       "scm: *"
//       ListLink
//            ExecutionOutputLink
//                 "scm: +"
//                 ListLink
//                     NumberNode 1
//                     NumberNode 2
//            NumberNode 3
//
// is a representation of (1 + 2) * 3
//
void SCMExecutionOutputUTest::test_nested(void)
{
	// Empty out the atomspace
	as->clear();
	size_t size = as->getSize();
	TS_ASSERT_EQUALS(size, 0);

	// Define various generic utilities
	eval->eval(
		"(define (oc-plus x y)"
		"   (NumberNode (number->string (+ "
		"      (string->number (cog-name x)) "
		"      (string->number (cog-name y))))))"
		"(define (oc-times x y)"
		"   (NumberNode (number->string (* "
		"      (string->number (cog-name x)) "
		"      (string->number (cog-name y))))))"
	);
	CHKEV(eval);

	eval->eval(
		"(define nestor"
		"   (ExecutionOutputLink "
		"      (GroundedSchemaNode \"scm: oc-times\")"
		"      (ListLink "
		"         (ExecutionOutputLink "
		"            (GroundedSchemaNode \"scm: oc-plus\")"
		"            (ListLink "
		"               (NumberNode \"1\")"
		"               (NumberNode \"2\")))"
		"         (NumberNode \"3\"))))"
	);
	CHKEV(eval);

	Handle enine = eval->eval_h("(cog-execute! nestor)");
	Handle nine = eval->eval_h("(NumberNode \"9\")");

	TS_ASSERT_EQUALS(nine, enine);
}
