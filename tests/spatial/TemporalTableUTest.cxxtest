/*
 * tests/atomspace/TemporalTableUTest.cxxtest
 *
 * Copyright (C) 2002-2007 Novamente LLC
 * All Rights Reserved
 *
 * Written by Welter Silva <welter@vettalabs.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/atoms/base/Node.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/spacetime/TemporalTable.h>
#include <opencog/util/Logger.h>
#include <opencog/util/numeric.h>

using namespace opencog;

#include "TemporalRelatedTestsCommons.h" // Declaration of constants and variables used for testing both get and remove methods 

class TemporalTableUTest :  public CxxTest::TestSuite
{
private:

    Temporal* times[N_TIMES];
    Handle handles[N_TIMES];

    TemporalTable *temporalTable;
    AtomSpace as;

public:

    TemporalTableUTest() {
        for (int i = 0; i < N_TIMES; i++) {
            times[i] = new Temporal(i*2, i*2);
            char name[16];
            sprintf(name, "%d", i);
            handles[i] = as.add_node(NUMBER_NODE, name);
        }
    }

    ~TemporalTableUTest() {
        for (int i = 0; i < N_TIMES; i++) {
            delete times[i];
        }
    }

    void setUp() {
        temporalTable = new TemporalTable();
    }

    void tearDown() {
        delete(temporalTable);
    }

    void testAdd() {
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            TS_ASSERT(!temporalTable->get(Handle::UNDEFINED, *(times[i])));
        }
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            TS_ASSERT(result);
            delete result;
            result = temporalTable->get(Handle::UNDEFINED, *(times[i]));
            TS_ASSERT(result);
            delete result;
        }
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[N_TIMES-1-i]));
        }
        for (int i = 0; i < N_TIMES; i++) {
            bool firstHalf = i < N_TIMES / 2;
            // Check times by handle
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                        times[firstHalf?i:(N_TIMES-i-1)]) == 0);
            TS_ASSERT(hte->next);
            hte = hte->next;
            TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                        times[firstHalf?(N_TIMES-i-1):i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Check handles by time
            result = temporalTable->get(Handle::UNDEFINED, *(times[i]));
            hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(),
                        handles[i]) == 0 ||
                    Handle::compare(hte->handleTemporalPair.getHandle(),
                        handles[N_TIMES-i-1]) == 0);
            TS_ASSERT(hte->next);
            hte = hte->next;
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(),
                        handles[i]) == 0 ||
                    Handle::compare(hte->handleTemporalPair.getHandle(),
                        handles[N_TIMES-i-1]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
        }
    }

    void testGetByHandle() {
        //HandleTemporalPairEntry* get(Handle);
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        for (int i = 0; i < N_TIMES; i++) {
            if (i < N_TIMES / 2) {
                // Insertions in ascendent order
                for (int j = 0; j < N_TIMES; j++) {
                    temporalTable->add(handles[i], *(times[j]));
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                    HandleTemporalPairEntry* hte = result;
                    for (int k = 0; k <= j; k++) {
                        TS_ASSERT(hte);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                    times[k]) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            } else {
                // Insertions in descendent order
                for (int j = N_TIMES - 1; j >= 0 ; j--) {
                    temporalTable->add(handles[i], *(times[j]));
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                    HandleTemporalPairEntry* hte = result;
                    for (int k = j; k < N_TIMES; k++) {
                        TS_ASSERT(hte);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                    times[k]) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            }
        }
    }

    void testGetByHandleAndTemporal() {
        //HandleTemporalPairEntry* get(Handle, Temporal*, bool)
        Temporal time (0, (N_TIMES - 1)*2);
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], time);
        }
        for (int i = 0; i < N_TIMES; i++) {
            if (i < N_TIMES / 2) {
                // Insertions in ascendent order
                for (int j = 0; j < N_TIMES; j++) {
                    temporalTable->add(handles[i], *(times[j]));
                    // Check times[0]
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i], *(times[0]));
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[0]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[0]), TemporalTable::OVERLAPS);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                                     (TemporalEntry::compare(&time, times[0]) < 0) ? &time : times[0]) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                                     (TemporalEntry::compare(&time, times[0]) > 0) ? &time : times[0]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check times[j]
                    result = temporalTable->get(handles[i], *(times[j]));
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[j]), TemporalTable::OVERLAPS);
                    hte = result;
                    //logger().debug("hte = %s", hte->toString().c_str());
                    //logger().debug("expected time = %s", ((TemporalEntry::compare(&time, times[j]) < 0)?&time:times[j])->toString().c_str());
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                                     (TemporalEntry::compare(&time, times[j]) < 0) ? &time : times[j]) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(),
                                                     (TemporalEntry::compare(&time, times[j]) > 0) ? &time : times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check with a time interval that contains all times
                    result = temporalTable->get(handles[i], time);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], time, TemporalTable::OVERLAPS);
                    hte = result;
                    for (int k = 0; k <= (j + 1); k++) {
                        TS_ASSERT(hte);
                        Temporal* expectedTime = (k == 0) ? times[0] : ((k > 1) ? times[k-1] : &time);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), expectedTime) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            } else {
                // Insertions in descendent order
                for (int j = N_TIMES - 1; j >= 0 ; j--) {
                    temporalTable->add(handles[i], *(times[j]));
                    // Check times[N_TIMES-1]
                    HandleTemporalPairEntry* result = temporalTable->get(handles[i], *(times[N_TIMES-1]));
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[N_TIMES-1]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[N_TIMES-1]), TemporalTable::OVERLAPS);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[N_TIMES-1]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check times[j]
                    result = temporalTable->get(handles[i], *(times[j]));
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], *(times[j]), TemporalTable::OVERLAPS);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), (j == 0) ? times[j] : &time) == 0);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), (j == 0) ? &time : times[j]) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    // Check with a time interval that contains all times
                    result = temporalTable->get(handles[i], time);
                    hte = result;
                    TS_ASSERT(hte);
                    TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), &time) == 0);
                    TS_ASSERT(!hte->next);
                    delete result;
                    result = temporalTable->get(handles[i], time, TemporalTable::OVERLAPS);
                    hte = result;
                    for (int k = j; k <= N_TIMES; k++) {
                        TS_ASSERT(hte);
                        Temporal* expectedTime = (j == 0) ? (k == 0 ? times[0] : k == 1 ? &time : times[k-1])
                                                         : (k == j ? &time : times[k-1]);
                        TS_ASSERT(TemporalEntry::compare(hte->handleTemporalPair.getTemporal(), expectedTime) == 0);
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            }
        }

    }

    void testGetByHandleAndTemporalWithOtherCriteria() {
        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], Temporal(i, i));     // [0,0]    [1,1]
            temporalTable->add(handles[i], Temporal(i + 1, i + 2));  // [1,2]    [2,3]
            temporalTable->add(handles[i], Temporal(i, i + 2)); // [0,2]    [1,3]
        }
        for (int h = 0; h < NUMBER_OF_HANDLES; h++) {
            for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
                for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                    HandleTemporalPairEntry* result = temporalTable->get(handles[h], search_intervals[t], criteria[c]);
                    HandleTemporalPairEntry* hte = result;
                    int numberOfReturnedEntries = hte->getSize();
                    if (numberOfReturnedEntries != expectedNumberOfEntries[h][t][c]) {
                        logger().debug("\nWrong number of entries returned for h=%s, t=%s, c=%s\nExpected %d, but got %d => %s",
                                       handles[h]->to_string().c_str(),
                                       search_intervals[t].toString().c_str(),
                                       TemporalTable::getTemporalRelationshipStr(criteria[c]),
                                       expectedNumberOfEntries[h][t][c], numberOfReturnedEntries, hte->toString().c_str());
                    }
                    TS_ASSERT(numberOfReturnedEntries == expectedNumberOfEntries[h][t][c]);
                    for (int i = 0; i < expectedNumberOfEntries[h][t][c]; i++) {
                        TS_ASSERT(hte);
                        if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterStartOf[h][t]) {
                                logger().debug("Next after start of t %s for h (%s) does not match\nExpected %s, but got %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               expectedNextAfterStartOf[h][t].toString().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterEndOf[h][t]) {
                                logger().debug("Next after end of t %s for h (%s) does not match\nExpected %s, but got %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               expectedNextAfterEndOf[h][t].toString().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterEndOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeStartOf[h][t]) {
                                logger().debug("Previous before start of t %s for h (%s) does not match\nExpected %s, but got %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               expectedPreviousBeforeStartOf[h][t].toString().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeEndOf[h][t]) {
                                logger().debug("Previous before end of t %s for h (%s) does not match\nExpected %s, but got %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               expectedPreviousBeforeEndOf[h][t].toString().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeEndOf[h][t]);
                        }
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;
                }
            }
        }
    }

    void testGetByTemporal() {
        //HandleTemporalPairEntry* get(Temporal*, bool = true);

        // Check if there is no entry yet
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }

        // Check association of all times to the first handle
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[0], *(times[i]));
        }
        // Exact match
        for (int i = 0; i < N_TIMES; i++) {
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(times[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }
        // Overlap match
        for (int i = 0; i < N_TIMES; i++) {
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(times[i]), TemporalTable::OVERLAPS);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }

        // Check association of the first time to all handles
        for (int i = 1; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[0]));
        }
        // Exact match
        HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(times[0]));
        HandleTemporalPairEntry* hte = result;
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
        // Overlap match
        result = temporalTable->get(Handle::UNDEFINED, *(times[0]), TemporalTable::OVERLAPS);
        hte = result;
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
    }

    // Special case 1: check different intervals contained by an existent interval
    void testGetByTemporalSpecialCase1() {
        Temporal time(0, 20);
        // Check if TemporalTable is empty
        TS_ASSERT(!temporalTable->get(Handle::UNDEFINED, time));
        TS_ASSERT(!temporalTable->get(Handle::UNDEFINED, time, TemporalTable::OVERLAPS));
        // Inserts new time
        temporalTable->add(handles[0], time);
        // Gets time with exact match
        HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, time);
        HandleTemporalPairEntry* hte = result;
        TS_ASSERT(hte);
        TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
        TS_ASSERT(!(hte->next));
        delete result;
        // Gets time with Overlap match
        result = temporalTable->get(Handle::UNDEFINED, time, TemporalTable::OVERLAPS);
        hte = result;
        TS_ASSERT(hte);
        TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
        TS_ASSERT(!(hte->next));
        delete result;
        // Lookups using several different times whose interval is contained by the interval of the inserted time
        for (int i = 0; i < N_TIMES; i++) {
            // Exact match does not return anything
            TS_ASSERT(!temporalTable->get(Handle::UNDEFINED, *(times[i])));
            // Overlap match return one entry for all times
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(times[i]), TemporalTable::OVERLAPS);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[0]) == 0);
            TS_ASSERT(!(hte->next));
            delete result;
        }
    }

    // Special case 2: check an interval that is contained by several existing intervals
    void testGetByTemporalSpecialCase2() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(i*2, (N_TIMES - i)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        Temporal time(N_TIMES, N_TIMES);
        // Exact match
        TS_ASSERT(!temporalTable->get(Handle::UNDEFINED, time));
        // Overlap match
        HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, time, TemporalTable::OVERLAPS);
        HandleTemporalPairEntry* hte = result;
        for (int i = 0; i < N_TIMES / 2; i++) {
            TS_ASSERT(hte);
            // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
            // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            hte = hte->next;
        }
        TS_ASSERT(!hte);
        delete result;
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    // Special case 3: check intervals that has the same lower bound of several existing intervals
    void testGetByTemporalSpecialCase3() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(0, i*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            hte = result;
            for (int j = 0; j < N_TIMES / 2; j++) {
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    // Special case 4: check intervals that has the same upper bound of several existing intervals
    void testGetByTemporalSpecialCase4() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(i*2, N_TIMES);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            hte = result;
            for (int j = 0; j < N_TIMES / 2; j++) {
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    // Special case 5: check intervals against several existing intervals that has many points of intersection with other intervals
    void testGetByTemporalSpecialCase5() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(i*2, (i + (N_TIMES / 2) - 2)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            hte = result;
            int howManyIntersections = (i > 0 && i < (N_TIMES / 2 - 1)) ? (N_TIMES / 2) : (N_TIMES / 2 - 1);
            for (int j = 0; j < howManyIntersections; j++) {
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    // Special case 6: check intervals against several existing intervals that has only one point of intersection with other intervals
    void testGetByTemporalSpecialCase6() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(i*2, (i + 1)*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            hte = result;
            int howManyIntersections = (i > 0 && i < (N_TIMES / 2 - 1)) ? 3 : 2;
            for (int j = 0; j < howManyIntersections; j++) {
                TS_ASSERT(hte);
                // Cannot ensure the order will be the same since it uses a HandleSet internally (not a sorted HandleEntry)
                // TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[j]) == 0);
                hte = hte->next;
            }
            TS_ASSERT(!hte);
            delete result;
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    // Special case 7: check intervals against several existing intervals that has no point of intersection with another intervals
    void testGetByTemporalSpecialCase7() {
        Temporal* specialTimes[N_TIMES/2];
        for (int i = 0; i < N_TIMES / 2; i++) {
            specialTimes[i] = new Temporal(i*2, i*2);
            temporalTable->add(handles[i], *(specialTimes[i]));
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            // Exact match
            HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]));
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
            // Overlap match
            // Exact match
            result = temporalTable->get(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(Handle::compare(hte->handleTemporalPair.getHandle(), handles[i]) == 0);
            TS_ASSERT(!hte->next);
            delete result;
        }
        for (int i = 0; i < N_TIMES / 2; i++) {
            delete specialTimes[i];
        }
    }

    void testGetByTemporalWithOtherCriteria() {
        for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
            temporalTable->add(handles[i], Temporal(i, i));     // [0,0]    [1,1]
            temporalTable->add(handles[i], Temporal(i + 1, i + 2));  // [1,2]    [2,3]
            temporalTable->add(handles[i], Temporal(i, i + 2)); // [0,2]    [1,3]
        }

        for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
            for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED, search_intervals[t], criteria[c]);
                HandleTemporalPairEntry* hte = result;
                int numberOfReturnedEntries = hte->getSize();
                int totalExpectedNumberOfEntries =
                    (criteria[c] != TemporalTable::NEXT_AFTER_START_OF &&
                     criteria[c] != TemporalTable::NEXT_AFTER_END_OF &&
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_START_OF &&
                     criteria[c] != TemporalTable::PREVIOUS_BEFORE_END_OF) ?
                    (expectedNumberOfEntries[0][t][c] + expectedNumberOfEntries[1][t][c]) :
                    (expectedNumberOfEntries[0][t][c] | expectedNumberOfEntries[1][t][c]);
                if (numberOfReturnedEntries != totalExpectedNumberOfEntries) {
                    logger().debug("\nWrong number of entries returned t=%s, c=%s\nExpected %d, but got %d => %s",
                                   search_intervals[t].toString().c_str(),
                                   TemporalTable::getTemporalRelationshipStr(criteria[c]),
                                   totalExpectedNumberOfEntries, numberOfReturnedEntries, hte->toString().c_str());
                }
                TS_ASSERT(numberOfReturnedEntries == totalExpectedNumberOfEntries);
                for (int i = 0; i < totalExpectedNumberOfEntries; i++) {
                    TS_ASSERT(hte);
                    if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) {
                        const Temporal& nextAfterStartOf =
                            (expectedNextAfterStartOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterStartOf[1][t] :
                            (expectedNextAfterStartOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterStartOf[0][t] :
                            (expectedNextAfterStartOf[0][t] < expectedNextAfterStartOf[1][t]) ?
                            expectedNextAfterStartOf[0][t] :
                            expectedNextAfterStartOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) != nextAfterStartOf) {
                            logger().debug("Next after start of t %s does not match\nExpected %s, but got %s",
                                           search_intervals[t].toString().c_str(),
                                           nextAfterStartOf.toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == nextAfterStartOf);
                    } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) {
                        const Temporal& nextAfterEndOf =
                            (expectedNextAfterEndOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterEndOf[1][t] :
                            (expectedNextAfterEndOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterEndOf[0][t] :
                            (expectedNextAfterEndOf[0][t] < expectedNextAfterEndOf[1][t]) ?
                            expectedNextAfterEndOf[0][t] :
                            expectedNextAfterEndOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) != nextAfterEndOf) {
                            logger().debug("Next after end of t %s does not match\nExpected %s, but got %s",
                                           search_intervals[t].toString().c_str(),
                                           nextAfterEndOf.toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == nextAfterEndOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) {
                        const Temporal& previousBeforeStartOf =
                            (expectedPreviousBeforeStartOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeStartOf[1][t] :
                            (expectedPreviousBeforeStartOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeStartOf[0][t] :
                            (expectedPreviousBeforeStartOf[0][t] > expectedPreviousBeforeStartOf[1][t]) ?
                            expectedPreviousBeforeStartOf[0][t] :
                            expectedPreviousBeforeStartOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) != previousBeforeStartOf) {
                            logger().debug("Previous before start of t %s does not match\nExpected %s, but got %s",
                                           search_intervals[t].toString().c_str(),
                                           previousBeforeStartOf.toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == previousBeforeStartOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) {
                        const Temporal& previousBeforeEndOf =
                            (expectedPreviousBeforeEndOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeEndOf[1][t] :
                            (expectedPreviousBeforeEndOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeEndOf[0][t] :
                            (expectedPreviousBeforeEndOf[0][t] > expectedPreviousBeforeEndOf[1][t]) ?
                            expectedPreviousBeforeEndOf[0][t] :
                            expectedPreviousBeforeEndOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) != previousBeforeEndOf) {
                            logger().debug("Previous before end of t %s does not match\nExpected %s, but got %s",
                                           search_intervals[t].toString().c_str(),
                                           previousBeforeEndOf.toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) == previousBeforeEndOf);
                    }
                    hte = hte->next;
                }
                TS_ASSERT(!hte);
                delete result;
            }
        }
    }

    void testRemoveByHandle() {
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Add entries
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes and check if ok
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
        // Adds entries again
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[i]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes in the inverse order and check if ok
        for (int i = N_TIMES - 1; i >= 0; i--) {
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j >= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
        // Now adds two entries for each handle
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[(i+1)%N_TIMES]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes and check if ok
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->remove(handles[i]);
            for (int j = 0; j < N_TIMES; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
    }

    void testRemoveByHandleAndTemporalExact() {
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes only one of the insertions of each handle and check
        for (int i = 0; i < N_TIMES - 1; i++) {
            if (i < N_TIMES / 2) {
                temporalTable->remove(handles[i], *(times[i]));
            } else {
                temporalTable->remove(handles[i], *(times[i+1]));
            }
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Removes the remaining insertions of each handle and check
        for (int i = 0; i < N_TIMES - 1; i++) {
            if (i < N_TIMES / 2) {
                temporalTable->remove(handles[i], *(times[i+1]));
            } else {
                temporalTable->remove(handles[i], *(times[i]));
            }
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
    }

    void testRemoveByHandleAndTemporalNonExact() {
        // FIRST TEST THE SAME CASES OF EXACT MATCH:
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes only one of the insertions of each handle and check
        for (int i = 0; i < N_TIMES - 1; i++) {
            if (i < N_TIMES / 2) {
                temporalTable->remove(handles[i], *(times[i]), TemporalTable::OVERLAPS);
            } else {
                temporalTable->remove(handles[i], *(times[i+1]), TemporalTable::OVERLAPS);
            }
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Removes the remaining insertions of each handle and check
        for (int i = 0; i < N_TIMES - 1; i++) {
            if (i < N_TIMES / 2) {
                temporalTable->remove(handles[i], *(times[i+1]), TemporalTable::OVERLAPS);
            } else {
                temporalTable->remove(handles[i], *(times[i]), TemporalTable::OVERLAPS);
            }
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j <= i) {
                    TS_ASSERT(!hte);
                } else {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);

        // TEST OTHER SPECIFIC CASES
        // Declares different times for using in this test
        Temporal* specialTimes[N_TIMES];
        for (int i = 0; i < N_TIMES; i++) {
            specialTimes[i] = new Temporal(0, i*2);
        }
        // Adds three entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            temporalTable->add(handles[i], *(specialTimes[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        /*
        logger().debug("All entries in TemporalTable = %s", temporalTable->get(Handle::UNDEFINED)->to_string().c_str());
        Temporal specialTime(0, (N_TIMES-1)*2); // overlaps any inserted time
        logger().debug("specialTime = %s", specialTime.to_string().c_str());
        temporalTable->remove(Handle::UNDEFINED, specialTime, TemporalTable::OVERLAPS);
        */
        // Removes the entries and check
        for (int i = 0; i < N_TIMES - 1; i++) {
            for (int j = 0; j < N_TIMES; j++) {
                // For each handle i => remove by times (0,j) => (0,1), (0,2), ..., (0,N)
                temporalTable->remove(handles[i], *(specialTimes[j]), TemporalTable::OVERLAPS);
                HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
                HandleTemporalPairEntry* hte = result;
                if (j < i) {
                    // [0,j+1] removed, [j,j] and [j+1,j+1] kept
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else if (j == i) {
                    // [j,j] [0,j+1] removed, [j+1,j+1] kept
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    // [j,j] [j+1,j+1] [0,j+1] removed
                    TS_ASSERT(!hte);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(Handle::UNDEFINED);
        //logger().debug("All entries in TemporalTable = %s", hte->to_string().c_str());
        TS_ASSERT(!hte);
        for (int i = 0; i < N_TIMES; i++) {
            delete specialTimes[i];
        }
    }

    void testRemoveByTemporalExact() {
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes each time and check
        for (int i = 0; i < N_TIMES; i++) {
            //logger().debug("i = %d", i);
            temporalTable->remove(Handle::UNDEFINED, *(times[i]));
            for (int j = 0; j < N_TIMES - 1; j++) {
                //logger().debug("j = %d", j);
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                //logger().debug("hte => %s", hte->to_string().c_str());
                if (j < i) {
                    TS_ASSERT(!hte);
                } else if (j == i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
    }

    void testRemoveByTemporalNonExact() {
        // FIRST TEST THE SAME CASES OF EXACT MATCH:
        // Check if it is empty
        for (int i = 0; i < N_TIMES; i++) {
            TS_ASSERT(!temporalTable->get(handles[i]));
        }
        // Adds two entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes each time and check
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->remove(Handle::UNDEFINED, *(times[i]), TemporalTable::OVERLAPS);
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                if (j < i) {
                    TS_ASSERT(!hte);
                } else if (j == i) {
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        HandleTemporalPairEntry* hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);

        // TEST OTHER SPECIFIC CASES
        // Declares different times for using in this test
        Temporal* specialTimes[N_TIMES];
        for (int i = 0; i < N_TIMES; i++) {
            specialTimes[i] = new Temporal(0, i*2);
        }
        // Adds some entries for each handle
        for (int i = 0; i < N_TIMES - 1; i++) {
            temporalTable->add(handles[i], *(times[i]));
            temporalTable->add(handles[i], *(times[i+1]));
            temporalTable->add(handles[i], *(specialTimes[i+1]));
            HandleTemporalPairEntry* result = temporalTable->get(handles[i]);
            HandleTemporalPairEntry* hte = result;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            hte = hte->next;
            TS_ASSERT(hte);
            TS_ASSERT(!hte->next);
            delete result;
        }
        // Removes the entries and check
        for (int i = 0; i < N_TIMES; i++) {
            temporalTable->remove(Handle::UNDEFINED, *(specialTimes[i]), TemporalTable::OVERLAPS);
            for (int j = 0; j < N_TIMES - 1; j++) {
                HandleTemporalPairEntry* result = temporalTable->get(handles[j]);
                HandleTemporalPairEntry* hte = result;
                //logger().debug("j= %d, i = %d, hte = %s", j, i, hte->to_string().c_str());
                if (j < i) {
                    // [j,j] [j+1,j+1] [0,j+1] removed
                    TS_ASSERT(!hte);
                } else if (j == i) {
                    // [j,j] [0,j+1] removed, [j+1,j+1] kept
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                } else {
                    // [0,j+1] removed, [j,j] and [j+1,j+1] kept
                    TS_ASSERT(hte);
                    hte = hte->next;
                    TS_ASSERT(hte);
                    TS_ASSERT(!hte->next);
                }
                delete result;
            }
        }
        // Check if they are all removed.
        hte = temporalTable->get(Handle::UNDEFINED);
        TS_ASSERT(!hte);
        for (int i = 0; i < N_TIMES; i++) {
            delete specialTimes[i];
        }
    }

    void testRemoveByHandleAndTemporalWithOtherCriteria() {
        for (int h = 0; h < NUMBER_OF_HANDLES; h++) {
            for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
                for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {
                    // adds all the entries for each removal test
                    for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
                        TS_ASSERT(!temporalTable->get(handles[i]));
                        temporalTable->add(handles[i], Temporal(i, i));     // [0,0]    [1,1]
                        temporalTable->add(handles[i], Temporal(i + 1, i + 2));  // [1,2]    [2,3]
                        temporalTable->add(handles[i], Temporal(i, i + 2)); // [0,2]    [1,3]
                    }
                    int totalNumberOfEntries = NUMBER_OF_HANDLES * 3;
                    HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED);
                    HandleTemporalPairEntry* hte = result;
                    TS_ASSERT(totalNumberOfEntries == hte->getSize());
                    delete result;

                    // Remove the entries
                    temporalTable->remove(handles[h], search_intervals[t], criteria[c]);

                    // Check if the entries were removed
                    result = temporalTable->get(Handle::UNDEFINED);
                    hte = result;
                    int numberOfReturnedEntries = hte->getSize();
                    if (numberOfReturnedEntries != (totalNumberOfEntries - expectedNumberOfEntries[h][t][c])) {
                        logger().debug("\nWrong number of entries returned for h=%s, t=%s, c=%s\nExpected %d, but got %d => %s",
                                       handles[h]->to_string().c_str(),
                                       search_intervals[t].toString().c_str(),
                                       TemporalTable::getTemporalRelationshipStr(criteria[c]),
                                       expectedNumberOfEntries[h][t][c], numberOfReturnedEntries, hte->toString().c_str());
                    }
                    TS_ASSERT(numberOfReturnedEntries == (totalNumberOfEntries - expectedNumberOfEntries[h][t][c]));


                    for (int i = 0; i < numberOfReturnedEntries; i++) {
                        TS_ASSERT(hte);
                        if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterStartOf[h][t]) {
                                logger().debug("Next after start of t %s for h (%s), that should have been removed is still there: %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) == expectedNextAfterEndOf[h][t]) {
                                logger().debug("Next after end of t %s for h (%s), that should have been removed is still there: %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedNextAfterEndOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeStartOf[h][t]) {
                                logger().debug("Previous before start of t %s for h (%s), that should have been removed is still there: %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeStartOf[h][t]);
                        } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) {
                            if (*(hte->handleTemporalPair.getTemporal()) == expectedPreviousBeforeEndOf[h][t]) {
                                logger().debug("Previous before end of t %s for h (%s), that should have been removed is still there: %s",
                                               search_intervals[t].toString().c_str(),
                                               handles[h]->to_string().c_str(),
                                               hte->handleTemporalPair.getTemporal()->toString().c_str());
                            }
                            TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != expectedPreviousBeforeEndOf[h][t]);
                        }
                        hte = hte->next;
                    }
                    TS_ASSERT(!hte);
                    delete result;

                    // reset the temporal table
                    delete temporalTable;
                    temporalTable = new TemporalTable();
                }
            }
        }
    }

    void testRemoveByTemporalWithOtherCriteria() {
        for (int t = 0; t < NUMBER_OF_SEARCH_INTERVALS; t++) {
            for (int c = 0; c < NUMBER_OF_CRITERIA; c++) {

                // adds all the entries for each removal test
                for (int i = 0; i < NUMBER_OF_HANDLES; i++) {
                    TS_ASSERT(!temporalTable->get(handles[i]));
                    temporalTable->add(handles[i], Temporal(i, i));     // [0,0]    [1,1]
                    temporalTable->add(handles[i], Temporal(i + 1, i + 2));  // [1,2]    [2,3]
                    temporalTable->add(handles[i], Temporal(i, i + 2)); // [0,2]    [1,3]
                }
                int totalNumberOfEntries = NUMBER_OF_HANDLES * 3;
                HandleTemporalPairEntry* result = temporalTable->get(Handle::UNDEFINED);
                HandleTemporalPairEntry* hte = result;
                TS_ASSERT(totalNumberOfEntries == hte->getSize());
                delete result;

                // Remove the entries
                temporalTable->remove(Handle::UNDEFINED, search_intervals[t], criteria[c]);

                // Check if the entries were removed
                result = temporalTable->get(Handle::UNDEFINED);
                hte = result;
                int numberOfReturnedEntries = hte->getSize();
                int totalExpectedNumberOfEntries = totalNumberOfEntries - (
                                                       (criteria[c] != TemporalTable::NEXT_AFTER_START_OF &&
                                                        criteria[c] != TemporalTable::NEXT_AFTER_END_OF &&
                                                        criteria[c] != TemporalTable::PREVIOUS_BEFORE_START_OF &&
                                                        criteria[c] != TemporalTable::PREVIOUS_BEFORE_END_OF) ?
                                                       (expectedNumberOfEntries[0][t][c] + expectedNumberOfEntries[1][t][c]) :
                                                       (expectedNumberOfEntries[0][t][c] | expectedNumberOfEntries[1][t][c])
                                                   );
                //logger().debug("expectedNumberOfEntries[0][t][c] = %d, expectedNumberOfEntries[1][t][c] = %d", expectedNumberOfEntries[0][t][c], expectedNumberOfEntries[1][t][c]);
                //logger().debug("nRetEntries = %d, totalExpEntries = %d", numberOfReturnedEntries, totalExpectedNumberOfEntries);
                if (numberOfReturnedEntries != totalExpectedNumberOfEntries) {
                    logger().debug("\nWrong number of entries returned t=%s, c=%s\nExpected %d, but got %d => %s",
                                   search_intervals[t].toString().c_str(),
                                   TemporalTable::getTemporalRelationshipStr(criteria[c]),
                                   totalExpectedNumberOfEntries, numberOfReturnedEntries, hte->toString().c_str());
                }
                TS_ASSERT(numberOfReturnedEntries == totalExpectedNumberOfEntries);
                for (int i = 0; i < totalExpectedNumberOfEntries; i++) {
                    TS_ASSERT(hte);
                    if (criteria[c] == TemporalTable::NEXT_AFTER_START_OF) {
                        const Temporal& nextAfterStartOf =
                            (expectedNextAfterStartOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterStartOf[1][t] :
                            (expectedNextAfterStartOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterStartOf[0][t] :
                            (expectedNextAfterStartOf[0][t] < expectedNextAfterStartOf[1][t]) ?
                            expectedNextAfterStartOf[0][t] :
                            expectedNextAfterStartOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) == nextAfterStartOf) {
                            logger().debug("Next after start of t %s, that should have been removed, is still there: %s",
                                           search_intervals[t].toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != nextAfterStartOf);
                    } else if (criteria[c] == TemporalTable::NEXT_AFTER_END_OF) {
                        const Temporal& nextAfterEndOf =
                            (expectedNextAfterEndOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterEndOf[1][t] :
                            (expectedNextAfterEndOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedNextAfterEndOf[0][t] :
                            (expectedNextAfterEndOf[0][t] < expectedNextAfterEndOf[1][t]) ?
                            expectedNextAfterEndOf[0][t] :
                            expectedNextAfterEndOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) == nextAfterEndOf) {
                            logger().debug("Next after end of t %s, that should have been removed, is still there: %s",
                                           search_intervals[t].toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != nextAfterEndOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_START_OF) {
                        const Temporal& previousBeforeStartOf =
                            (expectedPreviousBeforeStartOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeStartOf[1][t] :
                            (expectedPreviousBeforeStartOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeStartOf[0][t] :
                            (expectedPreviousBeforeStartOf[0][t] > expectedPreviousBeforeStartOf[1][t]) ?
                            expectedPreviousBeforeStartOf[0][t] :
                            expectedPreviousBeforeStartOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) == previousBeforeStartOf) {
                            logger().debug("Previous before start of t %s, that should have been removed, is still there: %s",
                                           search_intervals[t].toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != previousBeforeStartOf);
                    } else if (criteria[c] == TemporalTable::PREVIOUS_BEFORE_END_OF) {
                        const Temporal& previousBeforeEndOf =
                            (expectedPreviousBeforeEndOf[0][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeEndOf[1][t] :
                            (expectedPreviousBeforeEndOf[1][t] == UNDEFINED_TEMPORAL) ?
                            expectedPreviousBeforeEndOf[0][t] :
                            (expectedPreviousBeforeEndOf[0][t] > expectedPreviousBeforeEndOf[1][t]) ?
                            expectedPreviousBeforeEndOf[0][t] :
                            expectedPreviousBeforeEndOf[1][t];
                        if (*(hte->handleTemporalPair.getTemporal()) == previousBeforeEndOf) {
                            logger().debug("Previous before end of t %s, that should have been removed, is still there: %s",
                                           search_intervals[t].toString().c_str(),
                                           hte->handleTemporalPair.getTemporal()->toString().c_str());
                        }
                        TS_ASSERT(*(hte->handleTemporalPair.getTemporal()) != previousBeforeEndOf);
                    }
                    hte = hte->next;
                }
                TS_ASSERT(!hte);
                delete result;

                // reset the temporal table
                delete temporalTable;
                temporalTable = new TemporalTable();
            }
        }
    }

    void testStress() {
        int NUMBER_OF_ENTRIES = 100;
        //logger().debug("testStress(): adding...");
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = 0; j < N_TIMES; j++) {
                temporalTable->add(handles[i], *(times[j]));
            }
        }
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = N_TIMES; j < NUMBER_OF_ENTRIES; j++) {
                temporalTable->add(handles[i], Temporal(N_TIMES - 1, j));
            }
        }
        //logger().debug("testStress(): removing...");
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = 0; j < N_TIMES; j++) {
                temporalTable->remove(handles[i], *(times[j]));
            }
        }
        for (int i = 0; i < N_TIMES; i++) {
            for (int j = N_TIMES; j < NUMBER_OF_ENTRIES; j++) {
                temporalTable->remove(handles[i], Temporal(N_TIMES - 1, j));
            }
        }
    }

    void testSpecificRemoveCase1() {
        Handle h1 = as.add_node(CONCEPT_NODE, "H1");
        TemporalTable table;
        Temporal t1(100);
        Temporal t2(200);
        table.add(h1, t1);
        table.add(h1, t2);
        TS_ASSERT(table.remove(h1, Temporal(150), TemporalTable::STARTS_BEFORE));
        HandleTemporalPairEntry* result = table.get(h1);
        HandleTemporalPairEntry* htpe = result;
        TS_ASSERT(htpe);
        TS_ASSERT(htpe->handleTemporalPair.getHandle() == h1);
        TS_ASSERT(*(htpe->handleTemporalPair.getTemporal()) == t2);
        TS_ASSERT(table.remove(h1));
        htpe = table.get(h1);
        TS_ASSERT(!htpe);
        delete result;
    }

};
